<!DOCTYPE html>



  


<html class="theme-next gemini use-motion" lang="zh-Hans">
<head><meta name="generator" content="Hexo 3.9.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css">




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=5.1.2" rel="stylesheet" type="text/css">


  <meta name="keywords" content="Hexo, NexT">








  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.1.2">






<meta name="description" content="Python全栈开发">
<meta property="og:type" content="website">
<meta property="og:title" content="范澳河技术博客">
<meta property="og:url" content="http://yoursite.com/page/6/index.html">
<meta property="og:site_name" content="范澳河技术博客">
<meta property="og:description" content="Python全栈开发">
<meta property="og:locale" content="zh-Hans">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="范澳河技术博客">
<meta name="twitter:description" content="Python全栈开发">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Gemini',
    sidebar: {"position":"left","display":"post","offset":12,"offset_float":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: true,
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/page/6/">





  <title>范澳河技术博客</title>
  














</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left 
   page-home 
 ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">范澳河技术博客</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br>
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br>
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br>
            
            标签
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/10/15/python爬虫从入门到放弃（一）之初识爬虫/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="范澳河">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/微信图片_20190628155231.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="范澳河技术博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/10/15/python爬虫从入门到放弃（一）之初识爬虫/" itemprop="url">python爬虫从入门到放弃（一）之初识爬虫</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-10-15T00:21:57+08:00">
                2017-10-15
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/爬虫/" itemprop="url" rel="index">
                    <span itemprop="name">爬虫</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>整理这个文档的初衷是自己开始学习的时候没有找到好的教程和文本资料，自己整理一份这样的资料希望能对小伙伴有帮助</p>
<h3 id="什么是爬虫？"><a href="#什么是爬虫？" class="headerlink" title="什么是爬虫？"></a>什么是爬虫？</h3><p>网络爬虫（又被称为网页蜘蛛，网络机器人，在FOAF社区中间，更经常的称为网页追逐者），是一种按照一定的规则，自动地抓取万维网信息的程序或者脚本。另外一些不常使用的名字还有蚂蚁、自动索引、模拟程序或者蠕虫。</p>
<p>其实通俗的讲就是通过程序去获取web页面上自己想要的数据，也就是自动抓取数据</p>
<h3 id="爬虫可以做什么？"><a href="#爬虫可以做什么？" class="headerlink" title="爬虫可以做什么？"></a>爬虫可以做什么？</h3><p>你可以爬去妹子的图片，爬取自己想看看的视频。。等等你想要爬取的数据，只要你能通过浏览器访问的数据都可以通过爬虫获取</p>
<h3 id="爬虫的本质是什么？"><a href="#爬虫的本质是什么？" class="headerlink" title="爬虫的本质是什么？"></a>爬虫的本质是什么？</h3><p>模拟浏览器打开网页，获取网页中我们想要的那部分数据</p>
<p>浏览器打开网页的过程：<br>当你在浏览器中输入地址后，经过DNS服务器找到服务器主机，向服务器发送一个请求，服务器经过解析后发送给用户浏览器结果，包括html,js,css等文件内容，浏览器解析出来最后呈现给用户在浏览器上看到的结果</p>
<p>所以用户看到的浏览器的结果就是由HTML代码构成的，我们爬虫就是为了获取这些内容，通过分析和过滤html代码，从中获取我们想要资源（文本，图片，视频…..）</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/09/25/从yield 到yield from再到python协程/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="范澳河">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/微信图片_20190628155231.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="范澳河技术博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/09/25/从yield 到yield from再到python协程/" itemprop="url">从yield 到yield from再到python协程</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-09-25T00:21:57+08:00">
                2017-09-25
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/python/" itemprop="url" rel="index">
                    <span itemprop="name">python</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="从yield-到yield-from再到python协程"><a href="#从yield-到yield-from再到python协程" class="headerlink" title="从yield 到yield from再到python协程"></a>从yield 到yield from再到python协程</h3><h3 id="yield-关键字"><a href="#yield-关键字" class="headerlink" title="yield 关键字"></a>yield 关键字</h3><p>def fib():<br>    a, b = 0, 1<br>    while 1:<br>       yield b<br>       a, b = b, a+b</p>
<p>yield 是在：PEP 255 – Simple Generators 这个pep引入的</p>
<p>yield 只能在函数内部使用，包含yield语句的函数称为生成器函数</p>
<p>当调用生成器函数时，并不会执行函数体中的代码，而是返回一个生成器对象</p>
<p>每次调用生成器对象的next()方法时，才会执行生成器函数中的代码，直到遇到yield 或者return 语句。</p>
<p>如果遇到yield 语句， 怎会挂起函数的运行状态，并将yield 右边的表达式的值返回给next()的调用者， 挂起的时候会保存所有本地状态，包括局部变量，指令指针和内部堆栈信息，这样当下次再次调用next()时, 看起来yield 部分就像是调用了一个外部调用一样，可以接着往下执行</p>
<p>注意：try/ finnally 结构中的try子句中不允许使用yield语句， 问题是因为无法保证生成器被恢复，因此无法保证finally块将被执行</p>
<h3 id="yield-from-关键字"><a href="#yield-from-关键字" class="headerlink" title="yield from 关键字"></a>yield from 关键字</h3><p>yield from关键字是在：PEP 380 – Syntax for Delegating to a Subgenerator 中提出的</p>
<p>用于生成器将其部分操作委托给另外一个生成器，这允许将包含yield的一段代码分解出来并放在另外一个生成器中，此外，允许子生成器返回一个值，这个值可供委派生成器使用</p>
<p>上述描述听起来可能还是不是特别清楚，我们先看一下语法：</p>
<p>yield from <expr></expr></p>
<p>yield from expr 表达式中，做的第一件事就是调用iter(expr) 从中获取迭代器，因此expr可以是任何可迭代的对象</p>
<p>通过下面的下例子把yield 和yield from 做对比</p>
<p>from collections import namedtuple</p>
<p>Result = namedtuple(“Result”, “count average”)</p>
<p>li = [40.9, 38.5, 44.3, 42.2, 45.2, 41.7, 44.5, 38.0, 40.6, 44.5]</p>
<h1 id="子生成器"><a href="#子生成器" class="headerlink" title="子生成器"></a>子生成器</h1><p>def averager():<br>    total = 0.0<br>    count = 0<br>    average = None<br>    while True:<br>        term = yield<br>        if term is None:<br>            break<br>        total += term<br>        count += 1<br>        average = total/count<br>    return Result(count, average)</p>
<h1 id="委派生成器"><a href="#委派生成器" class="headerlink" title="委派生成器"></a>委派生成器</h1><p>def grouper(result, key):<br>    while True:<br>        result[key] = yield from averager()</p>
<h1 id="调用方"><a href="#调用方" class="headerlink" title="调用方"></a>调用方</h1><p>def main():<br>    results = {}<br>    group = grouper(results, “kg”)<br>    next(group)<br>    for value in li:<br>        group.send(value)<br>    group.send(None)</p>
<p>if <strong>name</strong> == “<strong>main</strong>“:<br>    main()</p>
<p>yield from的主要功能是打开双向通道，把最外层的调用方与最内层的子生成器连接起来，这样二者可以直接发送和产出值，还可以直接传入异常</p>
<p>yield from 的六个重要意义<br>关于yield from 六点重要的说明：</p>
<p>子生成器产出的值都直接传给委派生成器的调用方(即客户端代码)<br>使用send()方法发送给委派生成器的值都直接传给子生成器。如果发送的值为None,那么会给委派调用子生成器的<strong>next</strong>()方法。如果发送的值不是None,那么会调用子生成器的send方法，如果调用的方法抛出StopIteration异常，那么委派生成器恢复运行，任何其他异常都会向上冒泡，传给委派生成器<br>生成器退出时，生成器(或子生成器)中的return expr表达式会出发StopIteration(expr)异常抛出<br>yield from表达式的值是子生成器终止时传给StopIteration异常的第一个参数。yield from 结构的另外两个特性与异常和终止有关。<br>传入委派生成器的异常，除了GeneratorExit之外都传给子生成器的throw()方法。如果调用throw()方法时抛出StopIteration异常，委派生成器恢复运行。StopIteration之外的异常会向上冒泡，传给委派生成器<br>如果把GeneratorExit异常传入委派生成器，或者在委派生成器上调用close()方法，那么在子生成器上调用clsoe()方法，如果它有的话。如果调用close()方法导致异常抛出，那么异常会向上冒泡，传给委派生成器，否则委派生成器抛出GeneratorExit异常</p>
<h3 id="python协程"><a href="#python协程" class="headerlink" title="python协程"></a>python协程</h3><p>Python的生成器函数和python的协程非常接近 ,但并不完全 - 因为生成器然允许暂停执行以生成值，但是不提供在执行恢复时传递的值或异常。</p>
<p>并且生成器不允许在try / finally块的try部分中暂停执行，因此使中止的协程很难在其自身之后进行清理。</p>
<p>将yield重新定义为表达式，而不是语句。当前的yield语句将成为一个yield值表达式，其值将被丢弃。每当通过正常的next（）调用恢复生成器时，yield表达式的值为None<br>为generator-iterators 添加了一个新的方法send(), 它可以恢复生成器并发送给生成一个值，该值称为yield - expression的结果，send（）方法返回生成器产生的下一个值，如果生成器退出而不产生另一个值，则引发StopIteration。<br>为generator-iterators 添加了一个新的方法throw(), 它在生成器暂停时引发异常，并返回生成器产生的下一个值，如果生成器退出而不产生另一个值，则引发StopIteration（如果生成器没有捕获传入的异常，或者引发另外的一个异常，那么该异常会传播给调用者）<br>为generator-iterators 添加了一个新的方法close(), 在生成器暂停的位置引发一个GeneratorExit 异常，如果一个生成器引发了StopIteration 异常或者GeneratorExit 异常， close()方法将返回给它的调用者，如果生成是yield 一个值，会引发RuntimeError 异常。如果一个生成器引发了任何其他异常，则会传给他的调用者 ，如果生成器，由于异常退出或者已经正常退出，那么close()不执行任何操作。<br>确保了当生成器被垃圾回收的时候执行close()<br>因为垃圾回收或者clsoe被调用将允许允许yield在try / finally块中使用。<br>send方法<br>send方法只有一个参数，就是发送值到生成器，调用send(None)相当于调用生成器的next()方法</p>
<p>因为我们开始执行生成器函数的时候，并没有实际执行生成器函数中的代码而是返回一个生成器对象，所以我们需要调用next()或者send(None)来激活协程</p>
<p>与next（）方法一样，send（）方法返回generator-iterator产生的下一个值，如果生成器正常退出或已经退出，则引发StopIteration。如果生成器引发未捕获的异常，它将传播到send（）的调用者</p>
<p>throw方法<br>让生成器在被挂起的位置抛出指定的异常，如果生成器捕获了异常并且返回的另外一个值，那么这个值就是g.throw()返回的值</p>
<p>如果生成器没有捕获异常，那么throw()将会引发传递相同的异常，如果生成器引发了另外一个异常，throw调用将引发异常，总之throw()的行为类似next()或者send()</p>
<p>除了它在挂起的时候引发异常。如果生成器已经处于关闭状态，throw() 只会引发它传递的异常，而不执行任何生成器的代码</p>
<p>generator.throw:会让生成器在暂停的yield表达式处抛出指定的异常，如果生成器处理了抛出的异常，代码会向前执行到下一个yield表达式，而产出的值会成为调用generator.throw方法代码的返回值。如果生成器没有处理抛出的异常，异常会向上冒泡，传到调用方的上下文中。<br>generator.close:会让生成器在暂停的yield表达式处抛出GeneratorExit异常。如果生成器没有处理这个异常，或者抛出了StopIteration异常，调用方不会报错，如果收到GeneratorExit异常，生成器一定不能产出值，否则解释器会抛出RuntimeError异常。生成器抛出的异常会向上冒泡，传给调用方。</p>
<p>早期的python协程，语法上协程和生成器看起来也非常类似，也是通过yield关键字如：num = yield</p>
<p>def simple_coroutine():<br>    print(“coroutine start”)<br>    x = yield<br>    print(“coroutine receive [%s]” %x)</p>
<p>coroutine = simple_coroutine()<br>print(coroutine)<br>next(coroutine)<br>coroutine.send(888)</p>
<p>上面的例子中yield 的右边没有表达式，所以默认产出的值为None,通过之前将yield 关键字的时候我们已经知道当我们执行函数的时候</p>
<p>并不会运行生成器函数中的代码，而是返回一个生成器对象，所以我们需要通过调用next(…)来激活协程，这个时候开始运行生成器函数，</p>
<p>当运行到x = yield的时候，yield的右边如果有表达式，则会先进行右边表达式的计算，然后再进行赋值，所以当上面函数执行next()之后，</p>
<p>程序会停在yield那里，当我们调用send方法后yield会收到这个值并赋值给x,而当程序运行到协程定义体的末尾时和用生成器的时候一样会抛出StopIteration异常</p>
<p>如果协程没有通过next(…)激活(同样我们可以通过send(None)的方式激活)，但是我们直接send，则会出错</p>
<p>关于调用next(…)函数这一步通常称为”预激(prime)“协程，即让协程向前执行到第一个yield表达式，准备好作为活跃的协程使用</p>
<p>协程在运行过程中有四个状态：</p>
<p>GEN_CREATE:等待开始执行<br>GEN_RUNNING:解释器正在执行，这个状态一般看不到<br>GEN_SUSPENDED:在yield表达式处暂停<br>GEN_CLOSED:执行结束</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/09/06/关于python单例的常用几种实现方法/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="范澳河">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/微信图片_20190628155231.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="范澳河技术博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/09/06/关于python单例的常用几种实现方法/" itemprop="url">关于python单例的常用几种实现方法</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-09-06T00:21:57+08:00">
                2017-09-06
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/python/" itemprop="url" rel="index">
                    <span itemprop="name">python</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="关于python单例的常用几种实现方法"><a href="#关于python单例的常用几种实现方法" class="headerlink" title="关于python单例的常用几种实现方法"></a>关于python单例的常用几种实现方法</h3><p>这两天在看自己之前写的代码，所以正好把用过的东西整理一下，单例模式，在日常的代码工作中也是经常被用到，</p>
<p>所以这里把之前用过的不同方式实现的单例方式整理一下</p>
<p>装饰器的方式<br>这种方式也是工作中经常用的一种，用起来也比较方便，代码实现如下</p>
<p>def Singleton(cls):<br>    _instance = {}</p>
<pre><code>def _singleton(*args, **kwargs):
    if cls not in _instance:
        _instance[cls] = cls(*args, **kwargs)
    return _instance[cls]

return _singleton</code></pre><p>如果我们工作的一个类需要用单例就通过类似下面的方式实现即可：</p>
<p>@Singleton<br>class A(object):</p>
<pre><code>def __init__(self, x):
    self.x = x</code></pre><p>我个人还是挺喜欢这种方式的</p>
<p>类的方式实现<br>这里其实有一些问题就需要注意了，先看一下可能出现的错误代码</p>
<p>class Member(object):</p>
<pre><code>@classmethod
def instance(cls, *args, **kwargs):
    if not hasattr(Member, &quot;_instance&quot;):
        Member._instance = Member(*args, **kwargs)
    return Member._instance</code></pre><p>乍一看这个类好像已经实现了单例，但是这里有一个潜在的问题，就是如果是多线程的情况，这样写就会有问题了，尤其是在当前类的初始化对象里有一些耗时操作时候</p>
<p>例如下面代码：</p>
<p>#! /usr/bin/env python3</p>
<h1 id="coding-utf-8"><a href="#coding-utf-8" class="headerlink" title=".-- coding:utf-8 .--"></a>.-<em>- coding:utf-8 .-</em>-</h1><p>import time<br>import threading<br>import random</p>
<p>class Member(object):</p>
<pre><code>def __init__(self):
    time.sleep(random.randint(1,3))

@classmethod
def instance(cls, *args, **kwargs):
    if not hasattr(Member, &quot;_instance&quot;):
        Member._instance = Member(*args, **kwargs)
    return Member._instance</code></pre><p>def task(arg):<br>    obj = Member.instance()<br>    print(obj)</p>
<p>for i in range(5):<br>    t = threading.Thread(target=task, args=[i,])<br>    t.start()<br>这段代码的执行结果会出现实例化了多个对象，导致你写的单例就没起到作用</p>
<p>当然自然而然我们会想起加锁，通过锁来控制，所以我们将上面代码进行更改：</p>
<p>#! /usr/bin/env python3</p>
<h1 id="coding-utf-8-1"><a href="#coding-utf-8-1" class="headerlink" title=".-- coding:utf-8 .--"></a>.-<em>- coding:utf-8 .-</em>-</h1><p>import time<br>import threading<br>import random</p>
<p>class Member(object):<br>    _instance_lock = threading.Lock()</p>
<pre><code>def __init__(self):
    i = random.randint(1, 3)
    print(i)
    time.sleep(i)

@classmethod
def instance(cls, *args, **kwargs):
    with Member._instance_lock:
        if not hasattr(Member, &quot;_instance&quot;):
            Member._instance = Member(*args, **kwargs)
    return Member._instance</code></pre><p>def task():<br>    obj = Member.instance()<br>    print(obj)</p>
<p>for i in range(5):<br>    threading.Thread(target=task,).start()</p>
<p>但是上面的代码还有一个问题，就是当我们已经实例化过之后每次调用instance都会去请求锁，所以这点并不好，所以我们将这部分代码再次更改：</p>
<pre><code>@classmethod
def instance(cls, *args, **kwargs):
    if not hasattr(Member, &quot;_instance&quot;):
        with Member._instance_lock:
            if not hasattr(Member, &quot;_instance&quot;):
                Member._instance = Member(*args, **kwargs)
    return Member._instance</code></pre><p>这样就很好的实现一个可以多线程使用的单例</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/08/31/WebSocket 理论知识整理/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="范澳河">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/微信图片_20190628155231.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="范澳河技术博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/08/31/WebSocket 理论知识整理/" itemprop="url">WebSocket 理论知识整理</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-08-31T00:21:57+08:00">
                2017-08-31
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/python/" itemprop="url" rel="index">
                    <span itemprop="name">python</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>最近工作用到websocket, 之前虽然也用到了一些简单的东西，但是并没有认真整理一下。所以这次准备了解一下WebSocket.</p>
<h3 id="WebSocket产生的背景"><a href="#WebSocket产生的背景" class="headerlink" title="WebSocket产生的背景"></a>WebSocket产生的背景</h3><p>WebSocket是一种在单个TCP连接上进行全双工通信的协议. 这意味着双方可以同时进行通信和交换数据</p>
<p>对于我们都非常熟悉的HTTP协议，通信只能通过客户端发起，无法做到服务器主动向客户端推送消息<br>这样如果在服务端出问题的时候，客户端想要知道就比较麻烦，笨的办法就是我们采用轮询的方式，每隔一段时间问一下服务端：“喂，你还在么，你怎么样了，还没死吧？” 从而来确定服务端的一些状态变化。</p>
<p>关于轮询：其实就是客户端在指定的时间间隔向服务器发送请求</p>
<p>但是我们都知道这种笨办法是非常浪费资源的。而WebSocket也可以说就是这样诞生了</p>
<p>为什么我们需要web socket<br>Internet was conceived to be a collection of Hypertext Mark-up Language (HTML) pages linking one another to form a conceptual web of information. During the course of time, static resources increased in number and richer items, such as images and began to be a part of the web fabric.</p>
<p>Server technologies advanced which allowed dynamic server pages - pages whose content was generated based on a query.</p>
<p>Soon, the requirement to have more dynamic web pages lead to the availability of Dynamic Hypertext Mark-up Language (DHTML). All thanks to JavaScript. Over the following years, we saw cross frame communication in an attempt to avoid page reloads followed by HTTP Polling within frames.</p>
<p>However, none of these solutions offered a truly standardized cross browser solution to real-time bi-directional communication between a server and a client.</p>
<p>This gave rise to the need of Web Sockets Protocol. It gave rise to full-duplex communication bringing desktop-rich functionality to all web browsers.</p>
<h3 id="WebSocket-长啥样-？"><a href="#WebSocket-长啥样-？" class="headerlink" title="WebSocket 长啥样 ？"></a>WebSocket 长啥样 ？</h3><p>我们还是用HTTP来对比，我们通常访问一个网站如google,我们会在浏览器中输入：<br><a href="http://www.google.com" target="_blank" rel="noopener">http://www.google.com</a><br>或者：<br><a href="https://www.google.com" target="_blank" rel="noopener">https://www.google.com</a></p>
<p>其实webSocket和http也非常类似，如下图：<br><img src="https://img2018.cnblogs.com/blog/997599/201810/997599-20181022223435319-958405692.png" alt="avatar"></p>
<p><img src="https://img2018.cnblogs.com/blog/997599/201810/997599-20181022223448633-1124921322.png" alt="avatar"><br>web socket 是HTML5 规范的一部分， 允许网页和远程主机之间进行全双工通信，该协议实现以下好处：</p>
<p>通过单个连接而不是两个连接使用全双工减少不必要的网络流量和延迟<br>通过代理和防火墙进行流式传输，同时支持上游和下游通信</p>
<p>websocket 和http 对比<br><img src="https://img2018.cnblogs.com/blog/997599/201810/997599-20181022223509613-371398284.png" alt="avatar"></p>
<h3 id="websockets-角色"><a href="#websockets-角色" class="headerlink" title="websockets 角色"></a>websockets 角色</h3><p>Events and Actions<br>有四个主要的API events<br>Open<br>Message<br>Close<br>Error</p>
<p>每一个事件都分别通过实现onopen onmessage onclose 和onerror函数来处理</p>
<p>Open<br>一旦客户端和服务器之间建立了连接，就会从web socket 实例触发open 事件，这个被称为客户端和服务器之间的初始握手<br>一旦建立连接就会触发的事件称为onopen事件</p>
<p>Message<br>通常发生在服务器发送一些数据的时候触发该消息事件<br>服务器发送给客户端的消息可以包括纯文本消息，二进制数据或者图像。但是无论哪种数据都会触发onmessage函数</p>
<p>close<br>该事件标志着服务器和客户端之间通信结束<br>当触发onclose事件之后可以关闭连接，同时标记中通信结束，服务器和客户端之间无法进一步传输消息</p>
<p>error<br>onerror 事件之后总是随后终止连接</p>
<p>Actions<br>当我们想要发生某事件的时候做一些操作，通过用户显示调用的方法有：<br>send()<br>close()</p>
<p>参考连接：<a href="http://www.ruanyifeng.com/blog/2017/05/websocket.html" target="_blank" rel="noopener">http://www.ruanyifeng.com/blog/2017/05/websocket.html</a><br><a href="https://www.tutorialspoint.com/websockets/index.htm" target="_blank" rel="noopener">https://www.tutorialspoint.com/websockets/index.htm</a></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/08/20/一次python 内存泄漏解决过程/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="范澳河">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/微信图片_20190628155231.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="范澳河技术博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/08/20/一次python 内存泄漏解决过程/" itemprop="url">一次python 内存泄漏解决过程</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-08-20T00:21:57+08:00">
                2017-08-20
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/python/" itemprop="url" rel="index">
                    <span itemprop="name">python</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>最近工作中慢慢开始用python协程相关的东西，所以用到了一些相关模块，如aiohttp, aiomysql, aioredis等，用的过程中也碰到的很多问题，这里整理了一次内存泄漏的问题</p>
<p>通常我们写python程序的时候也很少关注内存这个问题（当然可能我的能力还有待提升），可能写c和c++的朋友会更多的考虑这个问题，但是一旦我们的python程序出现了</p>
<p>内存泄漏的问题，也将是一件非常麻烦的事情了，而最近的一次代码中也碰到了这个问题，不过好在最后内存溢出不是我代码的问题，而是所用到的一个包出现了内存的问题，下面我通过一个简单的代码模拟出内存的问题，然后也会将解决的过程描述一下，希望能帮助到遇到同样问题的朋友。</p>
<h3 id="一、复现问题"><a href="#一、复现问题" class="headerlink" title="一、复现问题"></a>一、复现问题</h3><p>其实这次主要是在使用aiohttp写一个接口的时候出现的问题，其实复现出问题非常容易，我们实现一个简单的接受post请求接口的服务端，然后实现一个并发的客户端来访问这个接口，来查看内存的情况</p>
<p>注意： 这个问题是在一个包的特定版本出现的：multidict==4.5.1,我在整理这个文章2个小时前作者已经修复了这个问题发布了4.5.2版本，已经修复了内存的问题，并且我也进行了测试验证</p>
<p>服务端代码：</p>
<p>from aiohttp import web</p>
<p>async def hello(request):<br>    return web.json_response(await request.json())</p>
<p>app = web.Application()<br>app.add_routes([web.post(‘/‘, hello)])<br>web.run_app(app)</p>
<p>客户端代码：</p>
<p>import asyncio<br>import aiohttp</p>
<p>async def foo(times):<br>    data = {‘foo’: 1}<br>    async with aiohttp.ClientSession() as session:<br>        for x in range(times):<br>            resp = await session.post(‘<a href="http://localhost:8080&#39;" target="_blank" rel="noopener">http://localhost:8080&#39;</a>, json=data)<br>            if not x % 100:<br>                print(await resp.json())</p>
<p>loop = asyncio.get_event_loop()<br>loop.run_until_complete(foo(100000))<br>loop.close()</p>
<p>因为我的代码是在linux上跑的，或者mac上我们都可以通过htop非常方面的实时查看我们程序内存的占用情况，我们先将服务端启动，查看一下我们此时的内存情况可以看到占用的</p>
<p>非常少，当我们打开客户端之后，再次观察我们可以看到内存不断增长，及时我们客户端运行完毕内存也不会降低。<br><img src="https://img2018.cnblogs.com/blog/997599/201811/997599-20181128233835760-673686395.png" alt="avatar"></p>
<p>当客户端结束之后的内存：<br><img src="https://img2018.cnblogs.com/blog/997599/201811/997599-20181128235917171-1022953452.png" alt="avatar"></p>
<p>如果客户端不停止的话内存会一直涨，最后的结果就是把你的系统内存吃完，然后被系统杀掉你的进程。</p>
<h3 id="二、解决内存泄漏的过程"><a href="#二、解决内存泄漏的过程" class="headerlink" title="二、解决内存泄漏的过程"></a>二、解决内存泄漏的过程</h3><p>像上面的例子是一个非常简单的程序，不复杂我们也并没有做上面复杂的操作就是一个简单的接受post请求的服务端，但是如果是在实际的项目中我们可能会写非常复杂的业务逻辑，那到时候我们又如何找到是哪里导致的内存问题，当我碰到这个问题的时候，其实我和很多接触python不久的人差不多，也是不知道怎么查这种问题，各种百度各种查，也找到了好多推荐的工具，memory_profiler库，objgraph库，graphviz工具，但是都没有帮助我迅速的找到问题点在哪里，最后看到标准库中的tracemalloc,地址：<a href="https://docs.python.org/3/library/tracemalloc.html" target="_blank" rel="noopener">https://docs.python.org/3/library/tracemalloc.html</a></p>
<p>通过这个包很快帮我找到了内存泄漏的地方</p>
<p>接下来按照官网的方法我将代码进行改写，来测试到底哪里的问题导致的内存泄漏，更改后的服务端代码为：</p>
<p>from aiohttp import web<br>import tracemalloc</p>
<p>async def hello(request):<br>    return web.json_response(await request.json())</p>
<p>async def get_info(request):<br>    snapshot2 = tracemalloc.take_snapshot()<br>    top_stats = snapshot2.compare_to(snapshot1, ‘lineno’)<br>    print(top_stats)<br>    return web.Response(text=”ok”)</p>
<p>if <strong>name</strong> == ‘<strong>main</strong>‘:<br>    app = web.Application()<br>    app.add_routes(<br>        [<br>            web.post(‘/‘, hello),<br>            web.get(“/get_info”, get_info)<br>        ]<br>    )<br>    tracemalloc.start()<br>    snapshot1 = tracemalloc.take_snapshot()<br>    web.run_app(app)</p>
<p>注意print(top_stats)这行打印的结果最后要关注<br> 其实这里就是新增加了一个路由get_info, 我们启动服务端之后开启客户端，当我们客户端运行完毕之后，可以看到内存已经涨上去了，并且没有不会释放，这个时候，可以直接通过浏览器访问get_info这个路由看看print打印的内容，这里将会打印出你程序运行到这个时候那一行的代码内存增长的比较多，进行一次排序，前面的几个其实都是需要你关注的，因为这里数据较多，我就只打印如下前几个数据</p>
<p>&lt;StatisticDiff traceback=&lt;Traceback (<frame filename="/Users/zhaofan/anaconda3/lib/python3.6/site-packages/aiohttp/web_response.py" lineno="56">,)&gt; size=116500672 (+116500672) count=300004 (+300004)&gt;,</p>
<p>&lt;StatisticDiff traceback=&lt;Traceback (<frame filename="/Users/zhaofan/anaconda3/lib/python3.6/site-packages/aiohttp/web_response.py" lineno="604">,)&gt; size=11400000 (+11400000) count=200000 (+200000)&gt;,</p>
<p>&lt;StatisticDiff traceback=&lt;Traceback (<frame filename="/Users/zhaofan/anaconda3/lib/python3.6/site-packages/aiohttp/web_response.py" lineno="472">,)&gt; size=8000000 (+8000000) count=100000 (+100000)&gt;,</p>
<p>&lt;StatisticDiff traceback=&lt;Traceback (<frame filename="/Users/zhaofan/anaconda3/lib/python3.6/site-packages/aiohttp/web_response.py" lineno="353">,)&gt; size=5500000 (+5500000) count=100000 (+100000)&gt;,</p>
<p>&lt;StatisticDiff traceback=&lt;Traceback (<frame filename="/Users/zhaofan/anaconda3/lib/python3.6/site-packages/aiohttp/web_response.py" lineno="352">,)&gt; size=5300608 (+5300608) count=100001 (+100001)&gt;,</p>
<p>我们拿第一行来说，我们可以非常清楚的指导web_response的56行代码导致内存增长的最多，当然如果是我们复杂的项目也可以通过类似的方法，这样就可以非常快捷的找到我们代码中哪些地方会造成内存溢出，便于排查问题，我们点进去看看这行代码：<br><img src="https://img2018.cnblogs.com/blog/997599/201811/997599-20181129003337645-688994262.png" alt="avatar"></p>
<p>我们找到最终行，这个时候我们大致就可以看出哪里的问题了，我们接着看  CIMultiDict</p>
<p>class CIMultiDict(MultiDict):</p>
<pre><code>def _title(self, key):
    return key.title()</code></pre><p>我们可以看到这个它继承  MultiDict 其实这里我们已经应该知道问题就是处在这个MultiDict上了</p>
<p>而这个最终其实最终就是MultiDict这个包，问题出在了这个包上，这个项目是在这里维护的：<a href="https://github.com/aio-libs/multidict" target="_blank" rel="noopener">https://github.com/aio-libs/multidict</a></p>
<p>查看这个包的时候看到了，果然有人和我遇到了同样的问题，问题就是出在这里了，已经有人提交了bug</p>
<p><a href="https://github.com/aio-libs/multidict/issues/307" target="_blank" rel="noopener">https://github.com/aio-libs/multidict/issues/307</a></p>
<p>不过不得不说国外的程序员真的是热爱自己的职业，很快这个问题得到了aio-libs小组中人的回应，问题也在我整理这个博客的时候被修复了，在最新的版本：4.5.2中已经测试没有内存泄漏的问题</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>在这里处理的过程中，其实发现了自己很多的不足，查找问题的方式，以及遇到这种问题的解决思路，不过经过这次，至少下次遇到同样的问题，自己能很快的去查找</p>
<p>以及解决问题，还有就是针对<a href="https://docs.python.org/3/library/tracemalloc.html这个库的使用，也推荐大家多了解一下。" target="_blank" rel="noopener">https://docs.python.org/3/library/tracemalloc.html这个库的使用，也推荐大家多了解一下。</a></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/08/11/linux环境快速安装python3/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="范澳河">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/微信图片_20190628155231.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="范澳河技术博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/08/11/linux环境快速安装python3/" itemprop="url">linux环境快速安装python3</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-08-11T00:21:57+08:00">
                2017-08-11
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/python/" itemprop="url" rel="index">
                    <span itemprop="name">python</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h4 id="linux环境快速安装python3"><a href="#linux环境快速安装python3" class="headerlink" title="linux环境快速安装python3"></a>linux环境快速安装python3</h4><p>之前在linux上安装python3的时候，为了让不影响linux环境原有的python2的环境，选择的方法都是下载对应的linux环境的python包，不过</p>
<p>这里需要注意的是,不要更改linux默认输入python 进入python2的方法，自己安装python3的时候做软链接的时候要做成python3,否则系统的很多工具依赖于python2,</p>
<p>而他们使用的是python2</p>
<p>但是编译安装还是非常慢的，推荐下面一种快速的方法</p>
<p>快速安装python3<br>这里以centos 为例子，先执行：</p>
<p>yum install python36<br>因为我这里环境用的是python3.6 你通过上面这个命令就可以把最新python3.6.6安装到linux。接着执行</p>
<p>yum install python36-devel<br>这个是安装一些依赖包，这个命令执行完毕之后，python3环境就安装成功了，但是这个时候你在linux上输入python3 是不可以进入python3的，</p>
<p>这种方法是默认安装到了/usr/bin/目录下，需要做软链接</p>
<p>ln -s /usr/bin/python3.6 /usr/bin/python3<br>还差最后一步，安装pip</p>
<p>python3 -m ensurepip<br>到此为止我们的python3环境就安装好了，相对于编译安装的方法还是快了很多的，尤其当你需要同时对多台机器同时安装python3的环境时候，通过这种方式就可以快速批量安装</p>
<p>所有的努力都值得期许，每一份梦想都应该灌溉！</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/07/28/git & github/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="范澳河">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/微信图片_20190628155231.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="范澳河技术博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/07/28/git & github/" itemprop="url">git & github</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-07-28T16:12:22+08:00">
                2017-07-28
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Web/" itemprop="url" rel="index">
                    <span itemprop="name">Web</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="为什么要使用版本控制"><a href="#为什么要使用版本控制" class="headerlink" title="为什么要使用版本控制"></a>为什么要使用版本控制</h3><p>　　　　1、举例说明：</p>
<p>　　　　　　1）假设你在的公司要上线一个新功能，你们开发团队为实现这个新功能，写了大约5000行代码，上线没2<br>　　　　　　     天，就发现这个功能用户并不喜欢，你老板让你去掉这个功能，你怎么办？<br>　　　　　　2）你说简单，直接把5000行代码去掉就行了，但是我的亲，说的简单，你的这个功能写了3周时间，但你<br>　　　　　　     还能记得你是新增加了哪5000行代码么？<br>　　　　　　3）所以你急需要一个工具，能帮你记录每次对代码做了哪些修改，并且可以轻易的把代码回滚到历史上的<br>　　　　　　     某个状态。 这个神奇的工具就叫做版本控制</p>
<p>　　　　2、版本控制工具主要实现2个功能</p>
<p>　　　　　　1）版本管理</p>
<p>　　　　　　　　　　在开发中，这是刚需，必须允许可以很容易对产品的版本进行任意回滚，版本控制工具实现这个功能的<br>　　　　　　　　　　原理简单来讲，就是你每修改一次代码，它就帮你做一次快照</p>
<p>　　　　　　2）协作开发</p>
<p>　　　　　　　　　　a. 一个复杂点的软件，往往不是一个开发人员可以搞定的，公司为加快产品开发速度，会招聘一堆跟<br>　　　　　　　　　　    你一样的开发人员开发这个产品<br>　　　　　　　　　　b. 拿微信来举例，现在假设3个人一起开发微信，A开发联系人功能，B开发发文字、图片、语音通讯<br>　　　　　　　　　　    功能，C开发视频通话功能， B和C的功能都是要基于通讯录的<br>　　　　　　　　　　c. 你说简单，直接把A开发的代码copy过来，在它的基础上开发就好了，可以，但是你在他的代码基<br>　　　　　　　　　　    础上开发了2周后，这期间A没闲着，对通讯录代码作了更新，此时怎么办？你和他的代码不一致<br>　　　　　　　　　　d. 此时我们知道，你肯定要再把A的新代码拿过来替换掉你手上的旧通讯录功能代码， 现在人少，3<br>　　　　　　　　　　    个人之间沟通很简单，但想想，如果团队变成30个人呢？<br>　　　　　　　　　　e. 来回这样copy代码，很快就乱了， 所以此时亟需一个工具，能确保一直存储最新的代码库，所有<br>　　　　　　　　　　    人的代码应该和最新的代码库保持一致</p>
<p>　　2. 常见版本管理工具介绍</p>
<p>　　　　1、SVN –CollabNet Subversion</p>
<p>　　　　　　　　1. SVN是集中式版本控制系统，版本库是集中放在中央服务器的，而干活的时候，用的都是自己的电脑，<br>　　　　　　　　2. 所以首先要从中央服务器哪里得到最新的版本，然后干活，干完后，需要把自己做完的活推送到中央服务器。<br>　　　　　　　　3. 集中式版本控制系统是必须联网才能工作，如果在局域网还可以，带宽够大，速度够快，如果在互联网下，如果网速慢的话，就纳闷了。</p>
<pre><code>2、GIT</code></pre><p>　　　　　　　　1. Git是分布式版本控制系统，那么它就没有中央服务器的，每个人的电脑就是一个完整的版本库，<br>　　　　　　　　2. 这样，工作的时候就不需要联网了，因为版本都是在自己的电脑上。<br>　　　　　　　　3. 你们两之间只需把各自的修改推送给对方，就可以互相看到对方的修改了，当然也可以推送到git的仓库中，比如GitHub</p>
<h3 id="git、GitHub和SVN比较"><a href="#git、GitHub和SVN比较" class="headerlink" title="git、GitHub和SVN比较"></a>git、GitHub和SVN比较</h3><p>1． Git</p>
<p>　　　　　　1、git是一个版本管理工具，是可以在你电脑不联网的情况下，只在本地使用的一个版本管理工具<br>　　　　　　2、其作用就是可以让你更好的管理你的程序，比如你原来提交过的内容，以后虽然修改了，但是通过git这个<br>　　　　 　　    工具，可以把你原来提交的内容重现出来</p>
<p>　　2. GitHub</p>
<p>　　　　　　1、github是一个网站，就是每个程序员自己写的程序，可以在github上建立一个网上的仓库，<br>　　　　　　2、你每次提交的时候可以把代码提交到网上，，这样你的每次提交，别人也都可以看到你的代码，同时别人也<br>　　　　　　     可以帮你修改你的代码，这种开源的方式非常方便程序员之间的交流和学习<br>　　　　　　3、github是一个非常适合程序员交流的网站，很多国际上的技术大牛都在github上有自己的开源代码，其他<br>　　　　　　     人只要申请个账号就可以随意的看到这些大牛写的程序<br>　　　　　　总结： git可以认为是一个软件，能够帮你更好的写程序，github则是一个网站，这个网站可以帮助程序员之间互相交流和学习。</p>
<p>　　3. SVN与git比较</p>
<p>　　　　　　1、Git是分布式的，SVN是集中式的，好处是跟其他同事不会有太多的冲突，自己写的代码放在自己电脑上，<br>　　　　　　      一段时间后再提交、合并，也可以不用联网在本地提交<br>　　　　　　2、Git下载下来后，在本地不必联网就可以看到所有的log，很方便学习，SVN却需要联网；<br>　　　　　　3、Git鼓励分Branch，而SVN，说实话，我用Branch的次数还挺少的，SVN自带的Branch merge我还真没用过<br>　　　　　　4、SVN在Commit前，我们都建议是先Update一下，跟本地的代码编译没问题，并确保开发的功能正常后再<br>　　　　　　     提交，这样其实挺麻烦的，有好几次同事没有先Updat，Commit了，发生了一些错误，Git可能这种情况</p>
<h3 id="本地git基本使用命令"><a href="#本地git基本使用命令" class="headerlink" title="本地git基本使用命令"></a>本地git基本使用命令</h3><ol>
<li>创建git版本库<br>　　　　　　1、版本库又名仓库，英文名repository，你可以简单理解成一个目录，<br>　　　　　　2、这个目录里面的所有文件都可以被Git管理起来，每个文件的修改、删除，Git都能跟踪，以便任何时刻都<br>　　　　　　     可以追踪历史，或者在将来某个时刻可以“还原”。<br>　　　　　　3、所以，创建一个版本库非常简单，首先，选择一个合适的地方，创建一个空目<br>　　　　　　4、瞬间Git就把仓库建好了，而且告诉你是一个空的仓库（empty Git repository）<br>　　　　　　5、细心的读者可以发现当前目录下多了一个.git的目录，这个目录是Git来跟踪管理版本库的，没事千万不要<br>　　　　　　     手动修改这个目录里面的文件，不然改乱了，就把Git仓库给破坏了。</li>
</ol>
<p>　　mkdir s15_gitpro                 #先创建一个项目<br>　　cd s15_gitpro/                   #切换到这个项目目录<br>　　git init                         #初始化这个<br>　　2. 工作区、暂存区、代码仓库<br>　　　　　　1、工作区： 就是你在电脑上看到的目录，比如目录下testgit里的文件(.git隐藏目录版本库除外)。<br>　　　　　　2、暂存区 :  暂存区就是文件夹 .git中的一个小部分（.git文件夹就是版本库）<br>　　　　　　3、版本库：工作区有一个隐藏目录.git,这个不属于工作区，这是版本库，  版本库中还有Git为我们<br>　　　　　　                   自动创建了第一个分支master,以及指向master的一个指针HEAD</p>
<p>　　　　　　4、    把文件添加到版本库分为以下三步：<br>　　　　　　　　1）vim Readme                        #工作区（Working Zone） 比如在mkdir s15_gitpro下执行创建文件命令<br>　　　　　　　　2）git add                                 #暂存区（Stage zone）<br>　　　　　　　　3）git commit                           #代码仓库（Repository master） 只有提交到代码库才能被git管理</p>
<p>　　3、本地git基本命令</p>
<p>　　　　1、将文件添加到仓库<br>　　　　　　　　git add Readme                       #指定将Readme文件添加到暂存区<br>　　　　　　　　git add .                                   #将当前目录中的所有文件全部添加到暂存区<br>　　　　　　　　git status                                 #查看更改了哪些，创建了哪些，哪些没有添加到仓库，哪些添加到了仓库<br>　　　　　　　　git status diff readme              #查看readme文件具体修改了哪些<br>　　　　　　　　git commit -m “commit tag”     # git commit告诉Git，把文件提交到仓库-m后面输入的是本次提交的说明(版本名字)</p>
<p>　　　　　　　　说明：<br>　　　　　　　　　　# 执行git commit 命令时必须配置用户信息<br>　　　　　　　　　　git config –global user.name “Tom Git”<br>　　　　　　　　　　git config –global user.email <a href="mailto:tom@example.com" target="_blank" rel="noopener">tom@example.com</a></p>
<p>　　　　2、回滚<br>　　　　　　　　git log                                         #查看所有提交到仓库的版本记录:   git log -2<br>　　　　　　　　git reflog                                     #查看所有操作记录（状态的md5值和改变的值）<br>　　　　　　　　git reset –hard d9e0ed0            #回到指定版本（d9e0ed0是创建版本的MD5值得前6位或者7位）<br>　　　　　　　　git reset –hard HEAD^               #回到上一个版本<br>　　　　　　　　注：这样可以回到第一次提交到仓库的状态，但再使用git log看不到其他几次的md5值了</p>
<p>　　　　3、撤销修改</p>
<p>　　　　　　　　vim Readme                               #我们在Readme文件中写了一些错误的代码<br>　　　　　　　　git add .                                      #然后又一不小心将文件从工作区提交到了 stage区<br>　　　　　　　　git reset HEAD Readme            #将Readme中刚提交到 stage区 的代码撤回到工作区<br>　　　　　　　　git status                                    #查看目前工作区状态<br>　　　　　　　　git checkout – Readme             #将Readme在工作区错误的代码丢弃</p>
<p>　　　　4、删除操作（两种方法）</p>
<p>　　　　　　　　方法1：这种方法需要执行git add .  </p>
<p>　　　　　　　　　　rm Readme<br>　　　　　　　　　　git add .<br>　　　　　　　　　　git commit -m “delete file by git rm”<br>　　　　　　　　　　git reset –hard HEAD^</p>
<p>　　　　　　　　方法2：这种方法可以省去执行git add .</p>
<p>　　　　　　　　　　git rm Readme<br>　　　　　　　　　　git commit -m “delete file by git rm”<br>　　　　　　　　　　git reset –hard HEAD^</p>
<p>　　　　　　　　注： 在没有git commit前，使用 git checkout – Readme 可以恢复删除的文件（Readme）</p>
<p>　　　　5、强制使用master覆盖本地代码</p>
<p>　　　　　　　　$ git fetch –all<br>　　　　　　　　$ git reset –hard origin/master<br>　　　　　　　　$ git pull</p>
<h3 id="使用git操作GitHub"><a href="#使用git操作GitHub" class="headerlink" title="使用git操作GitHub"></a>使用git操作GitHub</h3><pre><code>1、登录https://github.com 创建一个github项</code></pre><p><img src="https://images2017.cnblogs.com/blog/1080958/201801/1080958-20180104151351253-1830962882.png" alt="avatar"></p>
<pre><code>2、选择创建一个新项目，还是将本地的项目推到github这个项目里</code></pre><p><img src="https://images2017.cnblogs.com/blog/1080958/201801/1080958-20180104151525456-849656002.png" alt="avatar"></p>
<pre><code>3、将本地已有的项目上传到GitHub中
1）这里我们选择使用HTTPS的方法，讲本地已有项目提交到GitHub中</code></pre><p>　　　　2）在本地Git对应的项目下执行这条命令，配置，将以后的内容提交到这个路径下即：GitHub对应的项目中</p>
<p>　　　　　　git remote add origin <a href="https://github.com/Tom7481079/s15_proj.git" target="_blank" rel="noopener">https://github.com/Tom7481079/s15_proj.git</a>                    #设置代码提交url路径<br>　　　　　　git remote rm origin                                                                                             # 删除设置的代码提交url路径</p>
<p>　　　　3）将本地的项目推到GitHub中（需要输入GitHub网站的用户名和密码）<br>　　　　　　git push -u origin master                                                                                     # 将本地代码push到GitHub中</p>
<p>　　　　4）然后刷新页面即可在网页中看到我们本地的项目上传成功了</p>
<p> 　　4、GitHub中文件与本地项目不一致时上传到GitHub报错解决方法</p>
<p>　　　　方法一：使用强制push的方法，这样会使远程修改丢失，一般是不可取的，尤其是多人协作开发的时候。</p>
<p>　　　　　　　　git push -u origin master -f</p>
<p>　　　　方法二：push前先将远程repository修改pull下来</p>
<p>　　　　　　　　git pull origin master                                 # 先将GitHub中的文件下载到本地<br>　　　　　　　　git push -u origin master                           # 然后在push到GitHub中</p>
<p>　　　　　　　　注：执行git pull是如果只有GitHub中修改，会自动合并，如果本地也有修改必须手动合并才能正常git push</p>
<p>　　　　方法三：若不想merge远程和本地修改，可以先创建新的分支：</p>
<p>　　　　　　　　git branch [name]                                      # 新建一个分支<br>　　　　　　　　git push -u origin [name]                           # 提交到分支中</p>
<h3 id="配置win10当前用户对GitHub所有项目有权限（git-push不必输入密码）"><a href="#配置win10当前用户对GitHub所有项目有权限（git-push不必输入密码）" class="headerlink" title="配置win10当前用户对GitHub所有项目有权限（git push不必输入密码）"></a>配置win10当前用户对GitHub所有项目有权限（git push不必输入密码）</h3><pre><code>1、使用命令生成公钥和私钥（在git命令行中执行）</code></pre><p>　　　　　　ssh-keygen.exe               #生成一对公钥和私钥<br>　　　　　　C:\Users\tom.ssh           #这里是生成的秘钥地址</p>
<p>　　2、将公钥上传到GitHub中</p>
<p>　　　　1. 第一步<br><img src="https://images2017.cnblogs.com/blog/1080958/201801/1080958-20180105073615081-1871724160.png" alt="avatar"></p>
<pre><code>2. 第二步   </code></pre><p><img src="https://images2017.cnblogs.com/blog/1080958/201801/1080958-20180105073654846-1462734098.png" alt="avatar"></p>
<pre><code>3. 第三步</code></pre><p><img src="https://images2017.cnblogs.com/blog/1080958/201801/1080958-20180105073735253-1243925685.png" alt="avatar"><br>        4. 第四步<br><img src="https://images2017.cnblogs.com/blog/1080958/201801/1080958-20180105073827659-1537210954.png" alt="avatar"></p>
<pre><code>3. 更改本地push方式为ssh

    1. 配置完公钥后还需要将GitHub项目的push方式改成ssh</code></pre><p><img src="https://images2017.cnblogs.com/blog/1080958/201801/1080958-20180105074015112-1379203406.png" alt="avatar"></p>
<ol start="2">
<li>更改本地push方式为ssh</li>
</ol>
<p>　　　　　　1） vim .git/config<br>　　　　　　2） 将已有的https的路径替换成ssh模式，即上面复制的地址<br>　　　　　　　　#url = <a href="https://github.com/Tom7481079/s15_proj.git" target="_blank" rel="noopener">https://github.com/Tom7481079/s15_proj.git</a><br>　　　　　　　　url = <a href="mailto:git@github.com" target="_blank" rel="noopener">git@github.com</a>:Tom7481079/s15_proj.git</p>
<p>　　　　3、此时再执行品push命令时就不会再让输入用户名和密码了</p>
<p>　　　　　　　　git push origin master</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/07/21/Flask 在虚拟环境之中做开发/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="范澳河">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/微信图片_20190628155231.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="范澳河技术博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/07/21/Flask 在虚拟环境之中做开发/" itemprop="url">flask在虚拟环境中做开发</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-07-21T16:12:22+08:00">
                2017-07-21
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Web/" itemprop="url" rel="index">
                    <span itemprop="name">Web</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="Flask-在虚拟环境之中做开发"><a href="#Flask-在虚拟环境之中做开发" class="headerlink" title="Flask 在虚拟环境之中做开发"></a>Flask 在虚拟环境之中做开发</h2><p>虚拟环境可以搭建独立的python运行环境, 使得单个项目的运行环境与其它项目互不影响<br>比如一些项目基于python2.0，而另外一些项目却基于python3.0,同时这些项目必须在同一台服务器上部署，使用virtualenv就可以完美解决这个问题</p>
<p>虚拟环境安装命令<br>pip install virtualenv</p>
<p>进入项目安装虚拟目录的命令<br>virtualenv venv</p>
<p>激活虚拟环境<br>activate</p>
<p>离开虚拟环境<br>deactivate</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/07/13/socket模块/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="范澳河">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/微信图片_20190628155231.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="范澳河技术博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/07/13/socket模块/" itemprop="url">socket模块</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-07-13T16:12:22+08:00">
                2017-07-13
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Web/" itemprop="url" rel="index">
                    <span itemprop="name">Web</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="socket模块"><a href="#socket模块" class="headerlink" title="socket模块"></a>socket模块</h2><p>网络编程其他篇<br>目录：<br>1.1 socket理论部分<br>1.2 socket处理单个连接 和 同时接受多个连接<br>1.3 socket实现远程执行命令，下载文件<br>1.4 通过socket实现简单的ssh 和 处理连包问题<br> 1.1 socket理论部分     返回顶部<br>　　1、socket起源</p>
<p>　　　　　　1. socket起源于Unix，而Unix/Linux基本哲学之一就是“一切皆文件”，对于文件用【打开】【读写】【关闭】模式来操作。</p>
<p>　　　　　　2. socket就是该模式的一个实现，socket即是一种特殊的文件，一些socket函数就是对其进行的操作（读/写IO、打开、关闭）</p>
<p>　　　　　　3. 基本上，Socket 是任何一种计算机网络通讯中最基础的内容</p>
<p>　　　　　　4. 例如当你在浏览器地址栏中输入 <a href="http://www.cnblogs.com/" target="_blank" rel="noopener">http://www.cnblogs.com/</a> 时，你会打开一个套接字，然后连接到 <a href="http://www.cnblogs.com/" target="_blank" rel="noopener">http://www.cnblogs.com/</a> 并读取响应的页面然后然后显示出来</p>
<p>　　　　　　5. socket和file的区别：</p>
<p>　　　　　　　　1)  file模块是针对某个指定文件进行【打开】【读写】【关闭】</p>
<p>　　　　　　　　2)  socket模块是针对 服务器端 和 客户端Socket 进行【打开】【读写】【关闭】</p>
<p>　　2、socket.socket( family, type )  实例化一个socket类</p>
<p>　　　　1. 实例化需要3个参数</p>
<p>　　　　　　　　1）  第一个是地址簇(默认是socket.AF_INET)</p>
<p>　　　　　　　　2）  第二个是流(socket.SOCK_STREAM, 默认值)或数据报(socket.SOCK_DGRAM)套接字</p>
<p>　　　　　　　　3）  第三个是实用的协议（默认是0 使用默认即可），对于一个普通的套接字不需要提供任何参数</p>
<p>　　　　2. 第一个参数:  Socket Families(地址簇)  类似于OSI七层的网络层</p>
<p>　　　　　　　　1）socket.AF_UNIX     unix本机进程间通信(本机没有网卡时本机件进程自己起socket通信)</p>
<p>　　　　　　　　2）socket.AF_INET　  IPV4　</p>
<p>　　　　　　　　3）socket.AF_INET6  IPV6</p>
<p>　　　　3. 第二个参数:  Socket Families(地址簇)  类似于OSI七层的传输层</p>
<p>　　　　　　　　1）socket.SOCK_STREAM   #for tcp</p>
<p>　　　　　　　　2）socket.SOCK_DGRAM    #for udp </p>
<p>　　　　　　　　3）socket.SOCK_RAW    #原始套接字，普通的套接字无法处理ICMP、IGMP等网络报文，而SOCK_RAW可以；</p>
<p>　　　　　　　　    其次，SOCK_RAW也可以处理特殊的IPv4报文；此外利用原始套接字，可以通过IP_HDRINCL套接字选项由用户构造IP头</p>
<p>　　　　　　　　4）socket.SOCK_RDM    #是一种可靠的UDP形式，即保证交付数据报但不保证顺序。SOCK_RAM用来提供对原始协议低级访问，</p>
<p>　　　　　　　　    在需要执行某些特殊操作时使用，如发送ICMP报文。SOCK_RAM通常仅限于高级用户或管理员运行的程序使用</p>
<p>　　3、socket对象可以使用的所有方法</p>
<h1 id="1、-sk-bind-address"><a href="#1、-sk-bind-address" class="headerlink" title="1、 sk.bind(address)"></a>1、 sk.bind(address)</h1><p>　　  s.bind(address) 将套接字绑定到地址。address地址的格式取决于地址族。在AF_INET下，以元组（host,port）的形式表示地址。</p>
<h1 id="2、-sk-listen-backlog"><a href="#2、-sk-listen-backlog" class="headerlink" title="2、 sk.listen(backlog)"></a>2、 sk.listen(backlog)</h1><p>　　  开始监听传入连接。backlog指定在拒绝连接之前，可以挂起的最大连接数量。<br>      backlog等于5，表示内核已经接到了连接请求，但服务器还没有调用accept进行处理的连接个数最大为5<br>      这个值不能无限大，因为要在内核中维护连接队列</p>
<h1 id="3、-sk-setblocking-bool"><a href="#3、-sk-setblocking-bool" class="headerlink" title="3、 sk.setblocking(bool)"></a>3、 sk.setblocking(bool)</h1><p>　　 是否阻塞（默认True），如果设置False，那么accept和recv时一旦无数据，则报错。</p>
<h1 id="4、-sk-accept"><a href="#4、-sk-accept" class="headerlink" title="4、 sk.accept()"></a>4、 sk.accept()</h1><p>　　 接受连接并返回（conn,address）,其中conn是新的套接字对象，可以用来接收和发送数据。address是连接客户端的地址。<br>　　 接收TCP 客户的连接（阻塞式）等待连接的到来</p>
<h1 id="5、-sk-connect-address"><a href="#5、-sk-connect-address" class="headerlink" title="5、 sk.connect(address)"></a>5、 sk.connect(address)</h1><p>　　 连接到address处的套接字。一般，address的格式为元组（hostname,port）,如果连接出错，返回socket.error错误。</p>
<h1 id="6、-sk-connect-ex-address"><a href="#6、-sk-connect-ex-address" class="headerlink" title="6、 sk.connect_ex(address)"></a>6、 sk.connect_ex(address)</h1><p>　　 同上，只不过会有返回值，连接成功时返回 0 ，连接失败时候返回编码，例如：10061</p>
<h1 id="7、-sk-close"><a href="#7、-sk-close" class="headerlink" title="7、 sk.close()"></a>7、 sk.close()</h1><p>　　 关闭套接字</p>
<h1 id="8、-sk-recv-bufsize-flag"><a href="#8、-sk-recv-bufsize-flag" class="headerlink" title="8、 sk.recv(bufsize[,flag])"></a>8、 sk.recv(bufsize[,flag])</h1><p>　　 接受套接字的数据。数据以字符串形式返回，bufsize指定最多可以接收的数量。flag提供有关消息的其他信息，通常可以忽略。</p>
<h1 id="9、-sk-recvfrom-bufsize-flag"><a href="#9、-sk-recvfrom-bufsize-flag" class="headerlink" title="9、 sk.recvfrom(bufsize[.flag])"></a>9、 sk.recvfrom(bufsize[.flag])</h1><p>　　 与recv()类似，但返回值是（data,address）。其中data是包含接收数据的字符串，address是发送数据的套接字地址。</p>
<h1 id="10、-sk-send-string-flag"><a href="#10、-sk-send-string-flag" class="headerlink" title="10、 sk.send(string[,flag])"></a>10、 sk.send(string[,flag])</h1><p>　　 将string中的数据发送到连接的套接字。返回值是要发送的字节数量，该数量可能小于string的字节大小。即：可能未将指定内容全部发送。</p>
<h1 id="11、-sk-sendall-string-flag"><a href="#11、-sk-sendall-string-flag" class="headerlink" title="11、 sk.sendall(string[,flag])"></a>11、 sk.sendall(string[,flag])</h1><p>　　 将string中的数据发送到连接的套接字，但在返回之前会尝试发送所有数据。成功返回None，失败则抛出异常。<br>     内部通过递归调用send，将所有内容发送出去。</p>
<h1 id="12、-sk-sendto-string-flag-address"><a href="#12、-sk-sendto-string-flag-address" class="headerlink" title="12、 sk.sendto(string[,flag],address)"></a>12、 sk.sendto(string[,flag],address)</h1><p>　　 将数据发送到套接字，address是形式为（ipaddr，port）的元组，指定远程地址。返回值是发送的字节数。该函数主要用于UDP协议。</p>
<h1 id="13、-sk-settimeout-timeout"><a href="#13、-sk-settimeout-timeout" class="headerlink" title="13、 sk.settimeout(timeout)"></a>13、 sk.settimeout(timeout)</h1><p>　　 设置套接字操作的超时期，timeout是一个浮点数，单位是秒。值为None表示没有超时期。一般，超时期应该在刚创建套接字时设置，因为它们可能用于连接的操作（如 client 连接最多等待5s ）</p>
<h1 id="14、-sk-getpeername"><a href="#14、-sk-getpeername" class="headerlink" title="14、 sk.getpeername()"></a>14、 sk.getpeername()</h1><p>　　 返回连接套接字的远程地址。返回值通常是元组（ipaddr,port）。</p>
<h1 id="15、-sk-getsockname"><a href="#15、-sk-getsockname" class="headerlink" title="15、 sk.getsockname()"></a>15、 sk.getsockname()</h1><p>　　 返回套接字自己的地址。通常是一个元组(ipaddr,port)</p>
<h1 id="16、-sk-fileno"><a href="#16、-sk-fileno" class="headerlink" title="16、 sk.fileno()"></a>16、 sk.fileno()</h1><p>　　 套接字的文件描述符<br>　　4、TCP三层握手</p>
<p>1、第一次握手<br>建立连接时，客户端发送SYN包到服务器，其中包含客户端的初始序号seq=x，并进入SYN_SENT状态，等待服务器确认。</p>
<p>2、第二次握手<br>服务器收到请求后，必须确认客户的数据包。同时自己也发送一个SYN包，即SYN+ACK包，此时服务器进入SYN_RECV状态。</p>
<p>3、第三次握手<br>客户端收到服务器的SYN+ACK包，向服务器发送一个序列号(seq=x+1)，确认号为ack(客户端)=y+1，此包发送完毕，<br>客户端和服务器进入ESTAB_LISHED(TCP连接成功)状态，完成三次握手。</p>
<p>1、第一次挥手<br>首先，客户端发送一个FIN，用来关闭客户端到服务器的数据传送，然后等待服务器的确认。其中终止标志位FIN=1，序列号seq=u。</p>
<p>2、第二次挥手<br>服务器收到这个FIN，它发送一个ACK，确认ack为收到的序号加一。</p>
<p>3、第三次挥手<br>关闭服务器到客户端的连接，发送一个FIN给客户端。</p>
<p>4、第四次挥手<br>客户端收到FIN后，并发回一个ACK报文确认，并将确认序号seq设置为收到序号加一。<br>首先进行关闭的一方将执行主动关闭，而另一方执行被动关闭。</p>
<p>　　　　</p>
<p>1.2 socket处理单个连接 和 同时接受多个连接     返回顶部<br>　　1、socket通信原理图解</p>
<p>　　2、简单的socket列子：处理单个连接</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">import socket</span><br><span class="line">#服务器端</span><br><span class="line">server = socket.socket()         # 创建一个socket对象</span><br><span class="line">server.bind((&apos;&apos;,6969))           # host=’ ‘或者‘0.0.0.0’都表示所有计算机都可以访问服务器</span><br><span class="line">server.listen()                  # server.listen(5) 表示同时可以有五个客户连接到服务器</span><br><span class="line"></span><br><span class="line">conn,addr = server.accept()      # c, addr = s.accept() 这是一种赋变量的方法，会组成一个元组。</span><br><span class="line">                                 # 代表只要客户端提供地址（addr）就可以接受外部的链接</span><br><span class="line">data = conn.recv(1024)           # 收到客户端数据：recv默认是阻塞的，收到数据为空则死循环</span><br><span class="line">conn.send(data.upper())          # 服务器返回数据给client端</span><br><span class="line"></span><br><span class="line">server.close()</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">import socket</span><br><span class="line">#客户端</span><br><span class="line">client = socket.socket()                                                     # 创建socket对象</span><br><span class="line">client.connect((&apos;localhost&apos;,6969))                                          # 连接到服务端</span><br><span class="line">client.send(&quot;在python3中socket仅可以传送byte类型&quot;.encode(&quot;utf-8&quot;))        # 发送数据到服务端</span><br><span class="line">data = client.recv(1024)                                                     # 接收服务端返回数据</span><br><span class="line"></span><br><span class="line">print(&apos;客户端收到返回数据为：&apos;,data.decode())</span><br><span class="line">client.close()</span><br></pre></td></tr></table></figure>

<p>　　3、socket实现同时连接多个客户端</p>
<p>　　　　　　1. 这里仅能实现，同时连接多个客户端，但同一时刻仅能有一个客户端与服务的通信，其他客户端阻塞状态</p>
<p>　　　　　　2. 只有当前一个客户端断开连接后，后面的客户端才能与服务端发消息</p>
<p>　　　　　　3. 经测试，只能在Linux服务器中实现，在Windows中，断开客户端后服务端就会应发异常</p>
<p>#-<em>- coding:utf-8 -</em>-
import socket</p>
<p>#服务器端python3.5</p>
<p>server = socket.socket()<br>server.bind((‘’,6969))         #绑定要监听的端口<br>server.listen(5)                        #我要监听这个端口，最大连接数为：5<br>print(“我要开始等电话了”)<br>while True:                             #当一个客户端断开后程序就回到这里，等待下一个连接<br>    conn,addr = server.accept()         #等电话打进来   conn是打电话实例，addr电话号码</p>
<pre><code>#conn就是客户端连过来而在服务器端为其生成的连接实例，这里其实就是为每个客户端生成一个实例区分
while True:
    data = conn.recv(1024)         #data是接收到的从客户端发送过来的数据
    print(&quot;rect:&quot;,data)            #将客户端发送过来的数据在服务器端打印
    if not data:
    #如果客户端断开连接，data就为空，就跳出内层while循环，到达外层循环等待下一个客户端连接
        print(&quot;host has lost!!!&quot;)
        break
    conn.send(data.upper())       #将客户端发送来的数据变成大写，然后再发送给客户端</code></pre><p>server.close()</p>
<p>#-<em>- coding:utf-8 -</em>-
import socket</p>
<p>#客户端python3.5</p>
<p>client = socket.socket()                      #声明socket类型，同时生成socket连接对象<br>client.connect((‘1.1.1.3’,6969))            #指定要连接的服务器地址和端口号</p>
<p>while True:<br>    msg = input(“&gt;&gt;:”).strip()               #输入要发送给服务器的消息<br>    if len(msg) == 0:continue                #如果客户端输入空格，让客户端继续输入<br>    client.send(msg.encode(“utf-8”))         #将输入的消息发送到服务器端<br>    data = client.recv(1024)                 #接收服务器端发送过来的数据，每次1024字节<br>    print(‘client_recv:’,data)               #将从服务器端接收的数据在客户端打印出来<br>client.close()</p>
<p> 1.3 socket实现远程执行命令，下载文件     返回顶部<br> 　　1、使用socket实现远程执行命令</p>
<p>#-<em>- coding:utf-8 -</em>-
import socket,os</p>
<p>#服务器端python3.5<br>server = socket.socket()<br>server.bind((‘1.1.1.3’,6969))           #绑定要监听的端口<br>server.listen(5)                       #我要监听这个端口<br>print(“我要开始等电话了”)<br>while True:<br>    conn,addr = server.accept()         #等电话打进来   conn是打电话实例，addr电话号码<br>    while True:</p>
<pre><code>#conn就是客户端连过来而在服务器端为其生成的连接实例
data = conn.recv(1024)
data = data.decode()
print(&quot;接收的命令:&quot;,data)
if not data:
    print(&quot;host has lost!!!&quot;)
    break
res = os.popen(data).read()
conn.send(res.encode(&quot;utf-8&quot;))</code></pre><p>server.close()</p>
<p>#-<em>- coding:utf-8 -</em>-
import socket</p>
<p>#客户端python3.5<br>client = socket.socket()                      #声明socket类型，同时生成socket连接对象<br>client.connect((‘1.1.1.3’,6969))</p>
<p>while True:<br>    msg = input(“&gt;&gt;:”).strip()<br>    client.send(msg.encode(“utf-8”))<br>    data = client.recv(1024)</p>
<pre><code>print(&apos;客户端接收到服务端命令结果:&apos;,data.decode())</code></pre><p>client.close()</p>
<p>　　2、 socket实现下载文件</p>
<p>　　　　　　1）先在服务器上把要传送的视屏文件打开，用send发送给客户端<br>　　　　　　2）在客户端上打开一个新文件，将收到数据写入到文件中<br>　　　　　　3）测试结果是：在客户端每次输入任意符号服务器端就会发送一个1024字节的文件到客户端<br>　　　　　　4）可以看到的结果是，文件以1024的倍数增加</p>
<p>import socket,os</p>
<p>#socket服务器端<br>server = socket.socket()<br>server.bind((‘0.0.0.0’,2222))<br>server.listen(5)<br>while True:<br>    conn,addr = server.accept()<br>    while True:<br>        file_name = conn.recv(1024).decode()<br>        file_size = os.stat(file_name).st_size<br>        conn.send(str(file_size).encode(“utf-8”))<br>        with open(file_name,’rb’) as f:<br>            for line in f:<br>                conn.send(line)<br>server.close()</p>
<p>import  socket</p>
<p>#socket客户端<br>client = socket.socket()<br>client.connect((‘1.1.1.3’,2222))<br>while True:<br>    file_name = input(“please input you need to download file:”)<br>    client.send(file_name.encode(“utf-8”))<br>    file_size = client.recv(1024).decode()<br>    print(type(file_size),file_size)<br>    file_size = int(file_size)<br>    recv_size = 0<br>    with open(file_name + ‘.new’,’wb’) as f:<br>        while recv_size &lt; file_size:<br>            data = client.recv(1024)<br>            f.write(data)<br>            recv_size += 1024<br>client.close()</p>
<p> 1.4 通过socket实现简单的ssh 和 处理连包问题     返回顶部<br> 　　1、说明</p>
<p>　　　　　　1. 先运行服务器端，再运行客户端，客户端连接后发送数据给服务器端，服务器端将结果返回给客户端<br>　　　　　　2. 这段代码在windows python3.5中运行和 centos6.5系统中运行都正常<br>　　　　　　3. 下面用Windows作为客户端，centos6.5作为服务器端演示操作结果<br>　　　　　　4. 运行发现如果客户端服务端都在centos中运行时，客户端断开服务器端会继续监听下一个连接<br>　　　　　　5. 但是如果客户端是Windows无论服务器端是什么系统客户端断开服务器端就会自动断开</p>
<p> 　　2、socket实现ssh远程执行命令 及 处理连包问题</p>
<p>import socket,os</p>
<p>#ssh服务器端代码</p>
<p>server = socket.socket()<br>server.bind((‘0.0.0.0’,9999))        #0.0.0.0表示允许所有主机连接<br>server.listen()<br>print(“服务器端ssh开始监听客户端的链接啦！！”)</p>
<p>while True:<br>    conn,addr = server.accept()           #每次客户端断开，就会到这里等待新的连接<br>    while True:<br>        print(“等待新指令！！”)<br>        client_cmd = conn.recv(1024).decode()      #服务器端接收客户端发送过来的命令<br>        if not client_cmd:                #1 如果客户端断开连接收到的数据为空就会卡在这里<br>            print(“客户端已断开连接”)<br>            break<br>        print(“执行命令：”,client_cmd)<br>        cmd_res = os.popen(client_cmd).read()  #接收字符串，执行结果也是字符串<br>        print(“before send:”,len(cmd_res))     #打印出命令执行结果的长度<br>        if len(cmd_res) == 0:                 #2 如果命令错误则执行结果长度为 0<br>            cmd_res = “The command is wrong!!”<br>        conn.send( str(len(cmd_res.encode())).encode(“utf-8”) ) #发送命令结果长度<br>        client_ack = conn.recv(1024)         #3 为了解决连包问题可以在两个send中间加一个recv<br>        conn.send(cmd_res.encode(“utf-8”))   #将命令执行结果发送给客户端<br>        print(“send done”)<br>server.close()</p>
<p>import socket</p>
<p>#ssh 客户端程序代码</p>
<p>client = socket.socket()<br>client.connect((‘localhost’,9999))</p>
<p>while True:<br>    cmd = input(“请输入要执行的命令：”)<br>    if len(cmd) == 0:continue                 #1 客户端输入命令为空就不发送让他继续输入命令<br>    client.send(cmd.encode(“utf-8”))          #将要执行命令发送到服务器<br>    cmd_res_size = client.recv(1024).decode()     #接收命令结果的长度<br>    print(“执行命令结果的长度：”,cmd_res_size)  #打印要接收结果的数据长度<br>    client.send(‘ok’.encode(‘utf-8’))   #2 为解决连包问题可以在连续两次send中间加一个recv<br>    received_size = 0                #接收数据的长度初始值为 0<br>    received_data = b’’              #接收到的数据初始值为 空字符串<br>    while received_size &lt; int(cmd_res_size):<br>        data = client.recv(1024)          #每次从服务器端接收1024的数据<br>        received_size += len(data)        #接收到的数据长度累加<br>        received_data += data             #每次接收的数据累加到 received_data变量中<br>    else:<br>        print(“The command receive done:”,received_size) #打印最终接收的长度<br>        print(received_data.decode())          #将接收到的命令执行结果打印出来<br>client.close()</p>
<p>#1 在centos6.5  10.1.0.50服务器端运行结果：<br>[root@localhost python]# python35 ssh_server.sh<br>服务器端ssh开始监听客户端的链接啦！！<br>等待新指令！！<br>执行命令： df<br>before send: 429<br>send done<br>等待新指令！！</p>
<p>#2 在Windows 7中运行客户端的结果：<br>请输入要执行的命令：df<br>执行命令结果的长度： 429<br>The command receive done: 429<br>Filesystem                   1K-blocks    Used Available Use% Mounted on<br>/dev/mapper/VolGroup-lv_root  38744716 4118012  32658576  12% /<br>tmpfs                           510148     224    509924   1% /dev/shm<br>/dev/sda1                       495844   34846    435398   8% /boot<br>/dev/sr0                       4363088 4363088         0 100% /media/CentOS_6.5_Final<br>/dev/sr0                       4363088 4363088         0 100% /mnt</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/06/28/python设计模型/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="范澳河">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/微信图片_20190628155231.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="范澳河技术博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/06/28/python设计模型/" itemprop="url">python设计模型</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-06-28T16:12:22+08:00">
                2017-06-28
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Web/" itemprop="url" rel="index">
                    <span itemprop="name">Web</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="mvc和mvt的区别"><a href="#mvc和mvt的区别" class="headerlink" title="mvc和mvt的区别"></a>mvc和mvt的区别</h2><h3 id="mvc设计模式核心："><a href="#mvc设计模式核心：" class="headerlink" title="mvc设计模式核心："></a>mvc设计模式核心：</h3><pre><code>解耦，让不同的代码块之间降低耦合，增强代码的可扩展和可移植性，实现向后兼容。</code></pre><p><img src="https://img-blog.csdn.net/20170625152858644?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdTAxNDc0NTE5NA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="avatar"><br>MVC各部分的功能<br>M全拼为Model，主要封装对数据库层的访问，对数据库中的数据进行增、删、改、查操作。</p>
<p>V全拼为View，用于封装结果，生成页面展示的html内容。</p>
<p>C全拼为Controller，用于接收请求，处理业务逻辑，与Model和View交互，返回结果。</p>
<h2 id="Django中MVT设计模式"><a href="#Django中MVT设计模式" class="headerlink" title="Django中MVT设计模式"></a>Django中MVT设计模式</h2><h3 id="Django框架遵循MVC设计"><a href="#Django框架遵循MVC设计" class="headerlink" title="Django框架遵循MVC设计"></a>Django框架遵循MVC设计</h3><p><img src="https://img-blog.csdn.net/20170625153955366?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdTAxNDc0NTE5NA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="avatar"><br>MVT各部分的功能<br>M全拼为Model，与MVC中的M功能相同，负责和数据库交互，进行数据处理。</p>
<p>V全拼为View，与MVC中的C功能相同，接收请求，进行业务处理，返回应答。</p>
<p>T全拼为Template，与MVC中的V功能相同，负责封装构造要返回的html。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/5/"><i class="fa fa-angle-left"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/5/">5</a><span class="page-number current">6</span><a class="page-number" href="/page/7/">7</a><a class="extend next" rel="next" href="/page/7/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview sidebar-panel sidebar-panel-active">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image" src="/images/微信图片_20190628155231.jpg" alt="范澳河">
          <p class="site-author-name" itemprop="name">范澳河</p>
           
              <p class="site-description motion-element" itemprop="description">Python全栈开发</p>
          
        </div>
        <nav class="site-state motion-element">

          
            <div class="site-state-item site-state-posts">
              <a href="/archives/">
                <span class="site-state-item-count">61</span>
                <span class="site-state-item-name">日志</span>
              </a>
            </div>
          

          
            
            
            <div class="site-state-item site-state-categories">
              <a href="/categories/index.html">
                <span class="site-state-item-count">11</span>
                <span class="site-state-item-name">分类</span>
              </a>
            </div>
          

          
            
            
            <div class="site-state-item site-state-tags">
              <a href="/tags/index.html">
                <span class="site-state-item-count">14</span>
                <span class="site-state-item-name">标签</span>
              </a>
            </div>
          

        </nav>

        

        <div class="links-of-author motion-element">
          
        </div>

        
        

        
        

        


      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2019</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">范澳河</span>
</div>


<div class="powered-by">
  由 <a class="theme-link" href="https://hexo.io">Hexo</a> 强力驱动
</div>

<div class="theme-info">
  主题 -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Gemini
  </a>
</div>


        

        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.2"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.2"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.2"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.2"></script>



  
    <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.2"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.2"></script>

  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.2"></script>



  


  




	





  





  






  





  

  

  

  

  

  

</body>
</html>

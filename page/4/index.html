<!DOCTYPE html>



  


<html class="theme-next gemini use-motion" lang="zh-Hans">
<head><meta name="generator" content="Hexo 3.9.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css">




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=5.1.2" rel="stylesheet" type="text/css">


  <meta name="keywords" content="Hexo, NexT">








  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.1.2">






<meta name="description" content="Python全栈开发">
<meta property="og:type" content="website">
<meta property="og:title" content="范澳河技术博客">
<meta property="og:url" content="http://yoursite.com/page/4/index.html">
<meta property="og:site_name" content="范澳河技术博客">
<meta property="og:description" content="Python全栈开发">
<meta property="og:locale" content="zh-Hans">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="范澳河技术博客">
<meta name="twitter:description" content="Python全栈开发">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Gemini',
    sidebar: {"position":"left","display":"post","offset":12,"offset_float":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: true,
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/page/4/">





  <title>范澳河技术博客</title>
  














</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left 
   page-home 
 ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">范澳河技术博客</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br>
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br>
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br>
            
            标签
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/06/19/关于Django2.0跨域问题/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="范澳河">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/微信图片_20190628155231.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="范澳河技术博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/06/19/关于Django2.0跨域问题/" itemprop="url">关于Django2.0跨域问题</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-06-19T16:12:22+08:00">
                2018-06-19
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/django/" itemprop="url" rel="index">
                    <span itemprop="name">django</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="关于Django2-0跨域问题"><a href="#关于Django2-0跨域问题" class="headerlink" title="关于Django2.0跨域问题"></a>关于Django2.0跨域问题</h3><p>首页 - Python /2019-03-05<br>　　首先，明确一个问题，就是跨域需要服务端支持才行，而不是靠前端修改代码可以解决的，无论你用jquery axios fetch都是如此。</p>
<p>　　这里介绍一下，如果使用的是Django2.0本身作为web服务端，该如何处理跨域请求问题。</p>
<p>　　1 安装插件</p>
<p>　　pip install django-cors-headers</p>
<p>　　2 编辑配置文件(settings.py)</p>
<p>　　INSTALLED_APPS = [<br>    ‘’’’’’’’’’’’<br>    ‘’’’’’’’’’’’<br>    ‘’’’’’’’’’’’<br>    ‘’’’’’’’’’’’<br>    ‘’’’’’’’’’’’<br>    ‘corsheaders’,<br>]</p>
<p>MIDDLEWARE = [
    ‘django.middleware.security.SecurityMiddleware’,<br>    ‘django.contrib.sessions.middleware.SessionMiddleware’,</p>
<pre><code>&apos;corsheaders.middleware.CorsMiddleware&apos;, #这里是新增的中间件

&apos;django.middleware.common.CommonMiddleware&apos;,
&apos;django.middleware.csrf.CsrfViewMiddleware&apos;,
&apos;django.contrib.auth.middleware.AuthenticationMiddleware&apos;,
&apos;django.contrib.messages.middleware.MessageMiddleware&apos;,
&apos;django.middleware.clickjacking.XFrameOptionsMiddleware&apos;,</code></pre><p>]</p>
<p>CORS_ALLOW_CREDENTIALS = True<br>CORS_ORIGIN_ALLOW_ALL = True</p>
<p>至此，就可以解决跨域异步请求的问题了，服务端的不同配置也不一样，比如使用nginx服务就需要单独配置nginx才能让服务端支持，所以不能一概而论。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/06/18/get请求中的url encode问题/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="范澳河">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/微信图片_20190628155231.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="范澳河技术博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/06/18/get请求中的url encode问题/" itemprop="url">get请求中的url encode问题</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-06-18T00:21:57+08:00">
                2018-06-18
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/python/" itemprop="url" rel="index">
                    <span itemprop="name">python</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="get请求中的url-encode问题"><a href="#get请求中的url-encode问题" class="headerlink" title="get请求中的url encode问题"></a>get请求中的url encode问题</h3><p>首先发表一下感慨，Python的requests模块确实太简便，省却了很多的转码等等等等的问题，但这也是缺点，对于我这种基础不好的同学来说让我少知道了许多本来应该知道的东西。</p>
<p>url encode:</p>
<p>　　 对于get方法来说，都是把数据串联在请求的url后面作为参数，如：<a href="http://localhost:8080/servlet?msg=abc" target="_blank" rel="noopener">http://localhost:8080/servlet?msg=abc</a> （很常见的一个乱码问题就要出现了，如果url中出现中文或其它特殊字符的话，如：<a href="http://localhost:8080" target="_blank" rel="noopener">http://localhost:8080</a> /servlet?msg=杭州，服务器端容易得到乱码），url拼接完成后，浏览器会对url进行URL encode，然后发送给服务器，URL encode的过程就是把部分url做为字符，按照某种编码方式（如：utf-8,gbk等）编码成二进制的字节码，然后每个字节用一个包含3个字符的字符串 “%xy” 表示，其中xy为该字节的两位十六进制表示形式。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/06/05/深入tornado中的Configurable/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="范澳河">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/微信图片_20190628155231.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="范澳河技术博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/06/05/深入tornado中的Configurable/" itemprop="url">深入tornado中的Configurable</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-06-05T00:21:57+08:00">
                2018-06-05
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/python/" itemprop="url" rel="index">
                    <span itemprop="name">python</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="深入tornado中的Configurable"><a href="#深入tornado中的Configurable" class="headerlink" title="深入tornado中的Configurable"></a>深入tornado中的Configurable</h3><p>Configurable十分重要！ 位于tornado.util文件中,它是一个工厂类。</p>
<p>我们暂且称这个类为 配置类 。</p>
<p>我们暂且约定：该类的子类称之为 直属配置子类 ， 该类的孙类、重孙类……称之为 从属配置子类。就像这样：</p>
<p>class Configurable(object):  # 配置类<br>    pass</p>
<p>class IOLoop(Configurable):  # 直属配置子类<br>    pass</p>
<p>class PollIOLoop(IOLoop):  # 从属配置子类<br>    pass</p>
<p>这个配置类类似于java中的接口，他要求 直属配置子类必须有三个方法，分别是：</p>
<p><code>configurable_base</code>  <code>configurable_default</code> ‘initialize’<br>另外，在Configurable中定义了 <strong>new</strong>方法：</p>
<p>class Configurable(object):  # 配置类<br>    ‘’’<br>    要求其直属配置子类必须有以下三个方法：<br>        <code>configurable_base</code>      一般返回该直属配置子类自身<br>        <code>configurable_default</code>     返回该直属配置子类的执行类对象<br>        ‘initialize’             该直属配置子类的初始化方法<br>    ‘’’<br>    def <strong>new</strong>(cls, <em>args, **kwargs)<br>        ‘’’<br>        解析出impl对象<br>            1 cls是直属配置子类时，impl就是该直属配置子类的’执行类对象’<br>            2 cls是从属配置子类时，impl就是该从属配置子类自身<br>        然后实例化一个impl实例对象<br>        运行其initialize方法，并传入合并后的参数<br>        返回该impl实例对象<br>        ‘’’<br>        base = cls.configurable_base()<br>        init_kwargs = {}<br>        if cls is base:<br>            impl = cls.configured_class()<br>            if base.<strong>impl_kwargs:<br>                init_kwargs.update(base.</strong>impl_kwargs)<br>        else:<br>            impl = cls<br>        init_kwargs.update(kwargs)<br>        instance = super(Configurable, cls).<strong>new</strong>(impl)<br>        instance.initialize(</em>args, **init_kwargs)<br>        return instance</p>
<p>不太清楚<strong>new</strong>方法作用的同学请移步：Python中的<strong>init</strong>和<strong>new</strong></p>
<p>Configurable之所以这么重要，是因为他重写了<strong>new</strong>方法。</p>
<p>　　他的子类可以直接不用定义<strong>init</strong>方法，但必须使用initialize方法来替代<strong>init</strong></p>
<p>　　另外，当实例化Configurable子类对象时，所产生的实例对象对应的类并不一定会是该子类，有可能是其他类。。。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/05/19/深入tornado中的IOStream/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="范澳河">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/微信图片_20190628155231.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="范澳河技术博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/05/19/深入tornado中的IOStream/" itemprop="url">深入tornado中的IOStream</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-05-19T00:21:57+08:00">
                2018-05-19
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/python/" itemprop="url" rel="index">
                    <span itemprop="name">python</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="深入tornado中的IOStream"><a href="#深入tornado中的IOStream" class="headerlink" title="深入tornado中的IOStream"></a>深入tornado中的IOStream</h3><p>IOStream对tornado的高效起了很大的作用，他封装了socket的非阻塞IO的读写操作。大体上可以这么说，当连接建立后，服务端与客户端的请求响应的读写都是基于IOStream的，也就是说：IOStream是用来处理对连接的读写，当然IOStream是异步的读写而且可以有很多花样的读写。</p>
<p>接下来说一下有关接收请求的大体流程：</p>
<p>　　当连接建立，服务器端会产生一个对应该连接的socket，同时将该socket封装至IOStream实例中(这代表着IOStream的初始化)。</p>
<p>　　我们知道tornado是基于IO多路复用的(就拿epoll来说)，此时将socket进行register，事件为READABLE，这一步与IOStream没有多大关系。 </p>
<p>　　当该socket事件发生时，也就是意味着有数据从连接发送到了系统缓冲区中，这时就需要将chunk读入到我们在内存中为其开辟的_read_buffer中，在IOStream中使用deque作为buffer。_read_buffer表示读缓冲，当然也有_write_buffer，并且在读的过程中也会检测总尺寸是否大于我们设定的最大缓冲尺寸。不管是读缓冲还是写缓冲本质上就是tornado进程开辟的一段用来存储数据的内存。</p>
<p>　　而这些chunk一般都是客户端发送的请求了，但是我们还需要对这些chunk作进一步操作，比如这个chunk中可能包含了多个请求，如何把请求分离？(每个请求首部的结束符是b’\r\n\r\n’)，这里就用到read_until来分离请求并设置callback了。同时会将被分离的请求数据从_read_buffer中移除。</p>
<p>　　然后就是将callback以及他的参数(被分离的请求数据)添加至IOLoop._callbacks中，等待下一次IOLoop的执行，届时会迭代_callbacks并执行回调函数。　</p>
<p>　　补充： tornado是水平触发，所以假如读完一次chunk后系统缓存区中依然还有数据，那么下一次的epoll.poll()依然会返回该socket。</p>
<p>在iostream中有一个类叫做：IOStream  </p>
<p>有几个较为重要的属性：</p>
<p>def <strong>init</strong>():<br>    self.socket = socket           # 封装socket<br>    self.socket.setblocking(False) # 设置socket为非阻塞<br>    self.io_loop = io_loop or ioloop.IOLoop.current()<br>    self._read_buffer = deque()    # 读缓冲<br>    self._write_buffer = deque()   # 写缓冲<br>    self._read_callback = None     # 读到指定字节数据时，或是指定标志字符串时，需要执行的回调函数<br>    self._write_callback = None    # 发送完_write_buffer的数据时，需要执行的回调函数</p>
<p>有几个较为重要的方法</p>
<p>class IOStream(object):<br>    def read_until(self, delimiter, callback):<br>    def read_bytes(self, num_bytes, callback, streaming_callback=None):<br>    def read_until_regex(self, regex, callback):<br>    def read_until_close(self, callback, streaming_callback=None):<br>    def write(self, data, callback=None):<br>以上所有的方法都需要一个可选的callback参数，如果该参数为None则该方法会返回一个Future对象。</p>
<p>以上所有的读方法本质上都是读取该socket所发送来的数据，然后当读到指定分隔符或者标记或者条件触发的时候，停止读，然后将该分隔符以及其前面的数据作为callback(如果没有callback，则将数据设置为Future对象的result)的参数，然后将callback添加至IOLoop._callbacks中。当然其中所有的”读”操作是非阻塞的！</p>
<p>　　像read_until  read_until_regex 这两个方法相差不大，原理都是差不多的，都是在buffer中找指定的字符或者字符样式。</p>
<p>　　而read_bytes则是设置读取字节数，达到这些字节就会触发并运行回调函数(当然这些回调函数不是立刻运行，而是被送到ioloop中的_callbacks中)，该方法主要是用来读取包含content-length或者分块传输编码的具有主体信息的请求或者响应。</p>
<p>　　而read_until_close则是主要被用在非持久连接上，因为非持久连接响应的结束标志就是连接关闭。</p>
<p>read_bytes和read_until_close这两个方法都有streaming_callback这个参数，假如指定了该参数，那么只要read_buffer中有数据，则将数据作为参数调用该函数</p>
<p>就拿比较常见的read_until方法来说，下面是代码简化版：</p>
<pre><code>def read_until(self, delimiter, callback=None, max_bytes=None):
    future = self._set_read_callback(callback)  　 　# 可能是Future对象，也可能是None
    self._read_delimiter = delimiter　　　　　　　　　 # 设置分隔符
    self._read_max_bytes = max_bytes　　　　　　　　　 # 设置最大读字节数
    self._try_inline_read()
    return future</code></pre><p>其中_set_read_callback会根据callback是否存在返回None或者Future对象(存在返回None，否则返回一个Future实例对象)</p>
<p>如果我们<br>再来看_try_inline_read方法的简化版：</p>
<p>def _try_inline_read(self):<br>        “””<br>            尝试从_read_buffer中读取所需数据<br>        “””</p>
<pre><code># 查看是否我们已经在之前的读操作中得到了数据
self._run_streaming_callback() # 检查字符流回调，如果调用read_bytes和read_until_close并指定了streaming_callback参数就会造成这个回调
pos = self._find_read_pos()       # 尝试在_read_buffer中找到分隔符的位置。找到则返回分隔符末尾所处的位置，如果不能，则返回None。
if pos is not None:
    self._read_from_buffer(pos)
    return

self._check_closed()           # 检查当前IOStream是否关闭
pos = self._read_to_buffer_loop()  # 从系统缓冲中读取一个chunk，检查是否含有分隔符，没有则继续读取一个chunk，合并两个chunk，再次检查是否函数分隔符…… 如果找到了分隔符，会返回分隔符末尾在_read_buffer中所处的位置
if pos is not None:                # 如果找到了分隔符，
    self._read_from_buffer(pos)    # 将所需的数据从_read_buffer中移除，并将其作为callback的参数，然后将callback封装后添加至IOLoop._callbacks中     
    return

# 没找到分隔符，要么关闭IOStream，要么为该socket在IOLoop中注册事件
if self.closed():     
    self._maybe_run_close_callback()
else:
    self._add_io_state(ioloop.IOLoop.READ)</code></pre><p>上面的代码被我用空行分为了三部分，每一部分顺序的对应下面每一句话</p>
<p>分析该方法：</p>
<p>　　1 首先在_read_buffer第一项中找分隔符，找到了就将分隔符以及其前的数据从_read_buffer中移除并将其作为参数传入回调函数，没找到就将第二项与第一项合并然后继续找……；</p>
<p>　　2 如果在_read_buffer所有项中都没找到的话就把系统缓存中的数据读取至_read_buffer，然后合并再次查找，</p>
<p>　　3 如果把系统缓存中的数据都取完了都还没找到，那么就等待下一次该socket发生READ事件后再找，这时的找则就是：将系统缓存中的数据读取到_read_buffer中然后找，也就是执行第2步。</p>
<p> 来看一看这三部分分别调用了什么方法：<br><img src="https://images2015.cnblogs.com/blog/933924/201704/933924-20170418193910368-1741052409.png" alt="avatar"><br>第一部分中的_find_read_pos以及_read_from_buffer</p>
<p>前者主要是在_read_buffer中查找分隔符，并返回分隔符的位置，后者则是将分隔符以及分隔符前面的所有数据从_read_buffer中取出并将其作为callback的参数，然后将callback封装后添加至IOLoop._callbacks中</p>
<p>来看_find_read_pos方法的简化版：</p>
<p>def _find_read_pos(self): # 尝试在_read_buffer中寻找分隔符。找到则返回分隔符末尾所处的位置，如果不能，则返回None。<br>        if self._read_delimiter is not None:<br>            if self._read_buffer:    # 查看_read_buffer中是否有之前未处理的数据<br>                while True:<br>                    loc = self._read_buffer[0].find(self._read_delimiter) # 查找分隔符所出现的首部位置<br>                    if loc != -1:     # 在_read_buffer的首项中找到了<br>                        delimiter_len = len(self._read_delimiter)<br>                        self._check_max_bytes(self._read_delimiter, loc + delimiter_len)<br>                        return loc + delimiter_len    # 分隔符末尾的位置<br>                    if len(self._read_buffer) == 1:<br>                        break<br>                    _double_prefix(self._read_buffer)<br>                self._check_max_bytes(self._read_delimiter, len(self._read_buffer[0]))<br>        return None</p>
<p>def _read_from_buffer(self, pos): # 将所需的数据从_read_buffer中移除，并将其作为callback的参数，然后将callback封装后添加至IOLoop._callbacks中<br>        self._read_bytes = self._read_delimiter = self._read_regex = None<br>        self._read_partial = False<br>        self._run_read_callback(pos, False)</p>
<p>来看_run_read_callback源码简化版：<br>    def _run_read_callback(self, size, streaming):<br>        if streaming:<br>            callback = self._streaming_callback<br>        else:<br>            callback = self._read_callback<br>            self._read_callback = self._streaming_callback = None<br>            if self._read_future is not None:        # 这里将_read_future进行set_result<br>                assert callback is None<br>                future = self._read_future<br>                self._read_future = None<br>                future.set_result(self._consume(size))<br>        if callback is not None:<br>            assert (self._read_future is None) or streaming<br>            self._run_callback(callback, self._consume(size))    # 将后者作为前者的参数，然后将前者进行封装后添加至IOLoop._callbacks中</p>
<p>来看_consume的源码：<br>    def _consume(self, loc): # 将self._read_buffer 的首项改为 原首项[loc:] ，然后返回 原首项[:loc]<br>        if loc == 0:<br>            return b””<br>        _merge_prefix(self._read_buffer, loc)  # 将双端队列（deque）的首项调整为指定大小。<br>        self._read_buffer_size -= loc<br>        return self._read_buffer.popleft()</p>
<p>来看_run_callback源码简化版：<br>    def _run_callback(self, callback, <em>args):# 将callback封装后添加至ioloop._callbacks中<br>        def wrapper():<br>            self._pending_callbacks -= 1<br>            try:<br>                return callback(</em>args)<br>            finally:<br>                self._maybe_add_error_listener()<br>        with stack_context.NullContext():<br>            self._pending_callbacks += 1<br>            self.io_loop.add_callback(wrapper)    # 将callback添加至IOLoop._callbacks中</p>
<p>这里面还用到一个很有意思的函数：_merge_prefix ，这个函数的作用就是将deque的首项调整为指定大小</p>
<p>def _merge_prefix(deque, size):<br>    “””Replace the first entries in a deque of strings with a single<br>    string of up to size bytes.</p>
<pre><code>&gt;&gt;&gt; d = collections.deque([&apos;abc&apos;, &apos;de&apos;, &apos;fghi&apos;, &apos;j&apos;])
&gt;&gt;&gt; _merge_prefix(d, 5); print(d)
deque([&apos;abcde&apos;, &apos;fghi&apos;, &apos;j&apos;])

Strings will be split as necessary to reach the desired size.
&gt;&gt;&gt; _merge_prefix(d, 7); print(d)
deque([&apos;abcdefg&apos;, &apos;hi&apos;, &apos;j&apos;])

&gt;&gt;&gt; _merge_prefix(d, 3); print(d)
deque([&apos;abc&apos;, &apos;defg&apos;, &apos;hi&apos;, &apos;j&apos;])

&gt;&gt;&gt; _merge_prefix(d, 100); print(d)
deque([&apos;abcdefghij&apos;])
&quot;&quot;&quot;
if len(deque) == 1 and len(deque[0]) &lt;= size:
    return
prefix = []
remaining = size
while deque and remaining &gt; 0:
    chunk = deque.popleft()
    if len(chunk) &gt; remaining:
        deque.appendleft(chunk[remaining:])
        chunk = chunk[:remaining]
    prefix.append(chunk)
    remaining -= len(chunk)
if prefix:
    deque.appendleft(type(prefix[0])().join(prefix))
if not deque:
    deque.appendleft(b&quot;&quot;)</code></pre><p>第二部分的_read_to_buffer_loop</p>
<p>来看_read_to_buffer_loop简化版：<br>    系统缓冲中的data可能十分长，为了查找指定的字符，我们应该先读一个chunk，检查其中是否有指定的字符，若有则返回分隔符末尾所处的位置<br>    若没有则继续读第二个chunk，然后将这两个chunk合并(多字节分隔符（例如“\ r \ n”）可能跨读取缓冲区中的两个块)，重复查找过程</p>
<pre><code>def _read_to_buffer_loop(self):
    try:
        next_find_pos = 0
        self._pending_callbacks += 1
        while not self.closed():
            if self._read_to_buffer() == 0:    # 从系统缓冲中读一个chunk并将其添加至_read_buffer中，然后返回chunk的大小，如果无数据则返回0
                break
            self._run_streaming_callback()    
            if self._read_buffer_size &gt;= next_find_pos:    # _read_buffer_size 表示_read_buffer的大小
                pos = self._find_read_pos()    # 尝试在_read_buffer中寻找分隔符。找到则返回分隔符末尾所处的位置，如果不能，则返回None。 
                if pos is not None:
                    return pos
                next_find_pos = self._read_buffer_size * 2
        return self._find_read_pos()
    finally:
        self._pending_callbacks -= 1</code></pre><p>第三部分_add_io_state，该函数和ioloop异步相关</p>
<p>def _add_io_state(self, state):<br>        if self.closed():    # 连接已经关闭<br>            return<br>        if self._state is None:<br>            self._state = ioloop.IOLoop.ERROR | state<br>            with stack_context.NullContext():<br>                self.io_loop.add_handler(self.fileno(), self._handle_events, self._state) # 为对应socket的文件描述符添加事件及其处理函数,<br>        elif not self._state &amp; state:<br>            self._state = self._state | state<br>            self.io_loop.update_handler(self.fileno(), self._state)</p>
<pre><code># self._handle_events 是根据events选择对应的处理函数，在这里我们假设处理函数是_handle_read
def _handle_read(self):
    try:
        pos = self._read_to_buffer_loop()
    except UnsatisfiableReadError:
        raise
    except Exception as e:
        gen_log.warning(&quot;error on read: %s&quot; % e)
        self.close(exc_info=True)
        return
    if pos is not None:
        self._read_from_buffer(pos)
        return
    else:
        self._maybe_run_close_callback()</code></pre><p>参考：</p>
<p>　　<a href="http://www.nowamagic.net/academy/detail/13321051" target="_blank" rel="noopener">http://www.nowamagic.net/academy/detail/13321051</a></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/05/16/深入tornado中的协程/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="范澳河">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/微信图片_20190628155231.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="范澳河技术博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/05/16/深入tornado中的协程/" itemprop="url">深入tornado中的协程</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-05-16T00:21:57+08:00">
                2018-05-16
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/python/" itemprop="url" rel="index">
                    <span itemprop="name">python</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="深入tornado中的协程"><a href="#深入tornado中的协程" class="headerlink" title="深入tornado中的协程"></a>深入tornado中的协程</h3><p>tornado使用了单进程(当然也可以多进程) + 协程 + I/O多路复用的机制，解决了C10K中因为过多的线程(进程)的上下文切换 而导致的cpu资源的浪费。</p>
<p>tornado中的I/O多路复用前面已经讲过了。本文不做详细解释。</p>
<p>来看一下tornado中的协程模块：tornado.gen：</p>
<p>tornado.gen是根据生成器(generator)实现的，用来更加简单的实现异步。</p>
<p>先来说一下tornado.gen.coroutine的实现思路：</p>
<p>　　我们知道generator中的yield语句可以使函数暂停执行，而send()方法则可以恢复函数的执行。</p>
<p>　　tornado将那些异步操作放置到yield语句后，当这些异步操作完成后，tornado会将结果send()至generator中恢复函数执行。</p>
<p>在tornado的官方文档中有这么一句话：</p>
<p>Most asynchronous functions in Tornado return a Future; yielding this object returns its result.</p>
<p>就是说：</p>
<p>　　在tornado中大多数的异步操作返回一个Future对象</p>
<p>　　yield Future对象 会返回该异步操作的结果，这句话的意思就是说 假如 ret = yield some_future_obj 当some_future_obj所对应的异步操作完成后会自动的将该异步操作的结果赋值给 ret</p>
<p>那么，Future对象到底是什么？</p>
<p>一  Future对象<br>先来说说Future对象：</p>
<p>Future对象可以概括为： 一个异步操作的占位符，当然这个占位符有些特殊，它特殊在：</p>
<p>　　1 这个占位符是一个对象</p>
<p>　　2 这个对象包含了很多属性，包括_result 以及 _callbacks，分别用来存储异步操作的结果以及回调函数</p>
<p>　　3 这个对象包含了很多方法，比如添加回调函数，设置异步操作结果等。</p>
<p>　　4 当这个对象对应的异步操作完成后，该对象会被set_done，然后遍历并运行_callbacks中的回调函数</p>
<p>来看一下Future的简化版：</p>
<p>class Future(object):<br>    ‘’’<br>        Future对象主要保存一个回调函数列表<em>callbacks与一个执行结果<em>result，当我们set_result时，就会执行_callbacks中的函数<br>        如果set_result或者set_done，就会遍历_callbacks列表并执行callback(self)函数<br>    ‘’’<br>    def __init</em></em>(self):<br>        self._result = None    # 执行的结果<br>        self._callbacks = []    # 用来保存该future对象的回调函数</p>
<pre><code>def result(self, timeout=None):
    # 如果操作成功，返回结果。如果失败则抛出异常
    self._clear_tb_log()
    if self._result is not None:
        return self._result
    if self._exc_info is not None:
        raise_exc_info(self._exc_info)
    self._check_done()
    return self._result

def add_done_callback(self, fn):
    if self._done:
        fn(self)
    else:
        self._callbacks.append(fn)

def set_result(self, result):
    self._result = result
    self._set_done()

def _set_done(self):
    # 执行结束(成功)后的操作。
    self._done = True
    for cb in self._callbacks:
        try:
            cb(self)
        except Exception:
            app_log.exception(&apos;Exception in callback %r for %r&apos;, cb, self)
    self._callbacks = None</code></pre><p>完整源码：</p>
<p> Future源码</p>
<p>二  gen.coroutine装饰器<br>tornado中的协程是通过tornado.gen中的coroutine装饰器实现的：</p>
<p>def coroutine(func, replace_callback=True):<br>    return _make_coroutine_wrapper(func, replace_callback=True)<br>_make_coroutine_wrapper ：</p>
<p>def _make_coroutine_wrapper(func, replace_callback):<br>    @functools.wraps(func)<br>    def wrapper(<em>args, **kwargs):<br>        ‘’’<br>            大体过程：<br>            future = TracebackFuture()<br>            result = func(</em>args, **kwargs)<br>            if isinstance(result, GeneratorType):<br>                yielded = next(result)<br>                Runner(result, future, yielded)<br>            return future<br>        ‘’’<br>        future = TracebackFuture()                   # TracebackFuture = Future</p>
<pre><code>    if replace_callback and &apos;callback&apos; in kwargs:
        callback = kwargs.pop(&apos;callback&apos;)
        IOLoop.current().add_future(future, lambda future: callback(future.result()))

    try:
        result = func(*args, **kwargs)           # 执行func，若func中包含yield，则返回一个generator对象
    except (Return, StopIteration) as e:
        result = _value_from_stopiteration(e)
    except Exception:
        future.set_exc_info(sys.exc_info())
        return future
    else:
        if isinstance(result, GeneratorType):      # 判断其是否为generator对象
            try:
                orig_stack_contexts = stack_context._state.contexts
                yielded = next(result)            # 第一次执行
                if stack_context._state.contexts is not orig_stack_contexts:
                    yielded = TracebackFuture()
                    yielded.set_exception(
                        stack_context.StackContextInconsistentError(
                            &apos;stack_context inconsistency (probably caused &apos;
                            &apos;by yield within a &quot;with StackContext&quot; block)&apos;))
            except (StopIteration, Return) as e:
                future.set_result(_value_from_stopiteration(e))
            except Exception:
                future.set_exc_info(sys.exc_info())
            else:
                Runner(result, future, yielded)　　# Runner(result, future, yield)
            try:
                return future　　　　　　　　　　　　
            finally:
                future = None
    future.set_result(result)
    return future
return wrapper</code></pre><p>先来看一下大体过程：</p>
<p>　　1  首先生成一个Future对象</p>
<p>　　2  运行该被装饰函数并将结果赋值给result。 在这里因为tornado的’异步’实现是基于generator的，所以一般情况下 result是一个generator对象</p>
<p>　　3  yielded = next(result)  执行到被装饰函数的第一次yield，将结果赋值给yielded。一般情况下，yielded很大情况下是一个Future对象。</p>
<p>　　4  Runner(result, future, yielded)</p>
<p>　　5  return future</p>
<p>除了第4步以外其他都很好理解，所以来了解一下第四步Runner()干了些啥：</p>
<p>三  Runner()类<br>1 为什么要有Runner()？或者说Runner()的作用是什么？</p>
<p>Runner()可以自动的将异步操作的结果send()至生成器中止的地方</p>
<p>tornado的协程或者说异步是基于generator实现的，generator较为常用的有两个方法：send() next() ，关于这两个方法的流程分析在这。</p>
<p>很多情况下会有generator的嵌套。比如说经常会yield 一个generator。当A生成器yield B生成器时，分两步：</p>
<p>　　1 我们首先中止A的执行转而执行B</p>
<p>　　2 当B执行完成后，我们需要将B的结果send()至A中止的地方，继续执行A</p>
<p>Runner()主要就是来做这些的，也就是控制生成器的执行与中止，并在合适的情况下使用send()方法同时传入B生成器的结果唤醒A生成器。</p>
<p>来看一个简单例子：</p>
<p>def run():<br>    print(‘start running’)<br>    yield 2     # 跑步用时2小时</p>
<p>def eat():<br>    print(‘start eating’)<br>    yield 1     # 吃饭用时1小时</p>
<p>def time():<br>    run_time = yield run()<br>    eat_time = yield eat()<br>    print(run_time+eat_time)</p>
<p>def Runner(gen):<br>    r = next(gen)<br>    return r</p>
<p>t = time()<br>try:<br>    action = t.send(Runner(next(t)))<br>    t.send(Runner(action))<br>except StopIteration:<br>    pass</p>
<p>上例中的Runner()仅仅完成了第一步，我们还需要手动的执行第二步，而tornado的gen的Runner()则做了全套奥！</p>
<p>2 剖析Runner()</p>
<p>在Runner()中主要有三个方法<strong>init</strong>  handle_yield  run：</p>
<p>class Runner(object):<br>    def <strong>init</strong>(self, gen, result_future, first_yielded):<br>        self.gen = gen                        # 一个generator对象<br>        self.result_future = result_future    # 一个Future对象<br>        self.future = _null_future            # 一个刚初始化的Future对象  _null_future = Future(); _null_future.set_result(None)<br>        self.yield_point = None<br>        self.pending_callbacks = None<br>        self.results = None<br>        self.running = False<br>        self.finished = False<br>        self.had_exception = False<br>        self.io_loop = IOLoop.current()<br>        self.stack_context_deactivate = None<br>        if self.handle_yield(first_yielded):<br>            self.run()</p>
<pre><code>………… 部分方法省略
def run(self):
    &quot;&quot;&quot;Starts or resumes the generator, running until it reaches a
    yield point that is not ready.
    &quot;&quot;&quot;
    if self.running or self.finished:
        return
    try:
        self.running = True
        while True:
            future = self.future
            if not future.done():
                return
            self.future = None
            try:
                orig_stack_contexts = stack_context._state.contexts
                exc_info = None

                try:
                    value = future.result()
                except Exception:
                    self.had_exception = True
                    exc_info = sys.exc_info()

                if exc_info is not None:
                    yielded = self.gen.throw(*exc_info)
                    exc_info = None
                else:
                    yielded = self.gen.send(value)

                if stack_context._state.contexts is not orig_stack_contexts:
                    self.gen.throw(
                        stack_context.StackContextInconsistentError(
                            &apos;stack_context inconsistency (probably caused &apos;
                            &apos;by yield within a &quot;with StackContext&quot; block)&apos;))
            except (StopIteration, Return) as e:
                self.finished = True
                self.future = _null_future
                if self.pending_callbacks and not self.had_exception:
                    # If we ran cleanly without waiting on all callbacks
                    # raise an error (really more of a warning).  If we
                    # had an exception then some callbacks may have been
                    # orphaned, so skip the check in that case.
                    raise LeakedCallbackError(
                        &quot;finished without waiting for callbacks %r&quot; %
                        self.pending_callbacks)
                self.result_future.set_result(_value_from_stopiteration(e))
                self.result_future = None
                self._deactivate_stack_context()
                return
            except Exception:
                self.finished = True
                self.future = _null_future
                self.result_future.set_exc_info(sys.exc_info())
                self.result_future = None
                self._deactivate_stack_context()
                return
            if not self.handle_yield(yielded):
                return
    finally:
        self.running = False

def handle_yield(self, yielded):
    if _contains_yieldpoint(yielded):    # 检查其中是否包含YieldPoint
        yielded = multi(yielded)

    if isinstance(yielded, YieldPoint):        # Base class for objects that may be yielded from the generator
        self.future = TracebackFuture()        # 一个刚刚初始化的Future对象

        def start_yield_point():
            try:
                yielded.start(self)
                if yielded.is_ready():
                    self.future.set_result(yielded.get_result())
                else:
                    self.yield_point = yielded
            except Exception:
                self.future = TracebackFuture()
                self.future.set_exc_info(sys.exc_info())

        if self.stack_context_deactivate is None:
            with stack_context.ExceptionStackContext(self.handle_exception) as deactivate:
                self.stack_context_deactivate = deactivate

                def cb():
                    start_yield_point()
                    self.run()
                self.io_loop.add_callback(cb)
                return False
        else:
            start_yield_point()
    else:
        try:
            self.future = convert_yielded(yielded)
        except BadYieldError:
            self.future = TracebackFuture()
            self.future.set_exc_info(sys.exc_info())

    if not self.future.done() or self.future is moment:  # moment = Future()
        self.io_loop.add_future(self.future, lambda f: self.run()) # 为该future添加callback
        return False
    return True</code></pre><p>2.1 <strong>init</strong>方法</p>
<p><strong>init</strong> 里面执行了一些初始化的操作，最主要是最后两句：</p>
<p>if self.handle_yield(first_yielded): # 运行<br>    self.run()<br>2.2 handle_yield方法</p>
<p>handle_yield(self, yielded) 函数，这个函数顾名思义，就是用来处理yield返回的对象的。</p>
<p>首先我们假设yielded是一个Future对象(因为这是最常用的情况)，这样的话代码就缩减了很多</p>
<p>def handle_yield(self, yielded):<br>        self.future = convert_yielded(yielded)                         # 如果yielded是Future对象则原样返回<br>        if not self.future.done() or self.future is moment:            # moment是tornado初始化时就建立的一个Future对象，且被set_result(None)<br>            self.io_loop.add_future(self.future, lambda f: self.run()) # 为该future添加callback<br>            return False<br>        return True<br>也就是干了三步：</p>
<p>　　首先解析出self.future  </p>
<p>　　然后判断self.future对象是否已经被done(完成)，如果没有的话为其添加回调函数，这个回调函数会执行self.run()</p>
<p>　　返回self.future对象是否被done</p>
<p>总体来说，handle_yield返回yielded对象是否被set_done，如果没有则为yielded对象添加回调函数，这个回调函数执行self.run()</p>
<p>还有一个有趣的地方，就是上面代码的第四行：  self.io_loop.add_future(self.future, lambda f: self.run()) </p>
<p>def add_future(self, future, callback):</p>
<pre><code># 为future添加一个回调函数，这个回调函数的作用是：将参数callback添加至self._callbacks中
# 大家思考一个问题： 如果某个Future对象被set_done,那么他的回调函数应该在什么时候执行？ 
# 是立即执行亦或者是将回调函数添加到IOLoop实例的_callbacks中进行统一执行？ 
# 虽然前者更简单，但导致回调函数的执行过于混乱，我们应该让所有满足执行条件的回调函数统一执行。显然后者更合理
# 而add_future()的作用就是这样
future.add_done_callback(lambda future: self.add_callback(callback, future))</code></pre><p>def add_callback(self, callback, <em>args, *</em>kwargs):</p>
<pre><code># 将callback添加至_callbacks列表中
self._callbacks.append(functools.partial(callback, *args, **kwargs))</code></pre><p>2.3 run方法</p>
<p>再来看self.run()方法。这个方法实际上就是一个循环，不停的执行generator的send()方法，发送的值就是yielded的result。</p>
<p>我们可以将run()方法简化一下：</p>
<pre><code>def run(self):
    &quot;&quot;&quot;Starts or resumes the generator, running until it reaches a
    yield point that is not ready. 循环向generator中传递值，直到某个yield返回的yielded还没有被done
    &quot;&quot;&quot;
    try:
        self.running = True 
        while True:
            future = self.future　　
            if not future.done():
                return
            self.future = None　　　　　　# 清空self.future
            value = future.result()　　　# 获取future对象的结果
            try:    
                yielded = self.gen.send(value)　　# send该结果，并将self.gen返回的值赋值给yielded(一般情况下这也是个future对象)
            except (StopIteration, Return) as e:
                self.finished = True
                self.future = _null_future
                self.result_future.set_result(_value_from_stopiteration(e))
                self.result_future = None
                self._deactivate_stack_context()
                return
            if not self.handle_yield(yielded):　　# 运行self.handler_yield(yielded)，如果yielded对象没有被done，则直接返回；否则继续循环
                return
    finally:
        self.running = False</code></pre><p>总结：<br>　　1 每一个Future对应一个异步操作</p>
<p>　　2 该Future对象可以添加回调函数，当该异步操作完成后，需要对该Future对象设置set_done或者set_result，然后执行其所有的回调函数</p>
<p>　　3 凡是使用了coroutine装饰器的generator函数都会返回一个Future对象，同时会不断为该generator，该generator每一次运行send()或者next()的返回结果yielded以及future对象运行Runner()</p>
<p>　　4 Runner()会对generator不断进行send()或者next()操作。具体步骤是：上一个next()或者send()操作返回的yielded(一般是一个Future对象)被set_done后，将该yielded对象的结果send()至generator中，不断循环该操作，直到产生StopIteration或者Return异常(这表示该generator执行结束)，这时会为该generator对应的Future对象set_result。</p>
<pre><code>我们可以看到tornado的协程是基于generator的，generator可以通过yield关键字暂停执行，也可以通过next()或者send()恢复执行，同时send()可以向generator中传递值。

而将协程连接起来的纽带则是Future对象，每一个Future对象都对应着一个异步操作，我们可以为该对象添加许多回调函数，当异步操作完成后通过对Future对象进行set_done或者set_result就可以执行相关的回调函数。

提供动力的则是Runner()，他不停的将generator所yield的每一个future对象的结果send()至generator，当generator运行结束，他会进行最后的包装工作，对该generator所对应的Future对象执行set_result操作。</code></pre><p>参考：<br>　　<a href="http://blog.csdn.net/wyx819/article/details/45420017" target="_blank" rel="noopener">http://blog.csdn.net/wyx819/article/details/45420017</a></p>
<p>　　<a href="http://www.cnblogs.com/apexchu/p/4226784.html" target="_blank" rel="noopener">http://www.cnblogs.com/apexchu/p/4226784.html</a></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/04/28/什么是web框架？/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="范澳河">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/微信图片_20190628155231.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="范澳河技术博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/04/28/什么是web框架？/" itemprop="url">什么是web框架？</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-04-28T00:21:57+08:00">
                2018-04-28
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/python/" itemprop="url" rel="index">
                    <span itemprop="name">python</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="什么是web框架？"><a href="#什么是web框架？" class="headerlink" title="什么是web框架？"></a>什么是web框架？</h3><p>本文转自：<a href="http://www.cnblogs.com/hazir/p/what_is_web_framework.html#top" target="_blank" rel="noopener">http://www.cnblogs.com/hazir/p/what_is_web_framework.html#top</a></p>
<p>并对原文有微小改动</p>
<p>–引入</p>
<p>　　Web 应用框架，或者简单的说是“Web 框架”，其实是建立 web 应用的一种方式。从简单的博客系统到复杂的富 AJAX 应用，web 上每个页面都是通过写代码来生成的。我发现很多人都热衷于学习 web 框架技术，例如 Flask 或这 Django 之类的，但是很多人并不理解什么是 web 框架，或者它们是如何工作的。这篇文章中，我将探索反复被忽略的 web 框架基础的话题。阅读完这篇文章，你应该首先对什么是 web 框架以及它们为什么会存在有更深的认识。这会让你学习一个新的 web 框架变得简单的多，还会让你在使用不同的框架的时候做个明智的选择。</p>
<p>–web如何工作？</p>
<p>　　在我们讨论框架之前，我们需要理解 Web 如何“工作”的。为此，我们将深入挖掘你在浏览器里输入一个 URL 按下 Enter 之后都发生了什么。</p>
<p>　　在你的浏览器中打开一个新的标签，输入 <a href="http://www.jeffknupp.com" target="_blank" rel="noopener">http://www.jeffknupp.com</a>  。在这里我们讨论：为了显示这个页面，浏览器都做了什么事情（不涉及 DNS 查询）。</p>
<p>–web服务器</p>
<p>　　每个页面都以 HTML 的形式传送到你的浏览器中，HTML 是一种浏览器用来描述页面内容和结构的语言。那些负责发送 HTML 到用户浏览器的应用称之为“Web 服务器”，会让你迷惑的是，这些应用运行的机器通常也叫做 web 服务器。</p>
<p>然而，最重要的是要理解，到最后所有的 web 应用要做的事情就是发送 HTML 到浏览器。不管应用的逻辑多么复杂，最终的结果总是将 HTML 发送到浏览器（我故意将应用可以响应像 JSON 或者 CSS 等不同类型的数据忽略掉，因为在概念上是相同的）。</p>
<p>web 应用如何知道发送什么到浏览器呢？这个问题很重要，但我们先存疑，接下来会讲述到的。</p>
<p>–http</p>
<p>浏览器从 web 服务器（或者叫应用服务器）上使用 HTTP 协议下载网页，HTTP 协议是基于一种 请求-响应（request-response）模型的协议。客户端（你的浏览器）从运行在物理机器上的 web 应用（服务器端）请求数据，web 应用反过来对你的浏览器请求进行响应。</p>
<p>重要的一点是，要记住通信总是由客户端（你的浏览器）发起的，服务器（也就是 web 服务器）没有办法创建一个链接，发送没有经过请求的数据给你的浏览器。如果你从 web 服务器上接收到数据，一定是因为你的浏览器显示地发送了请求。</p>
<p>–HTTP Methods</p>
<p>在 HTTP 协议中，每条报文都关联方法（method 或者 verb），不同的 HTTP 方法对应客户端可以发送的逻辑上不同类型的请求，反过来也代表了客户端的不同意图。例如，请求一个 web 页面的 HTML，与提交一个表单在逻辑上是不同的，所以这两种行为就需要使用不同的方法。</p>
<p>这里讲较为常用的、重要的两个方法：GET  和 POST</p>
<p>GET：</p>
<p>　　从 web 服务器上 get（请求）数据，GET 请求是到目前位置最常见的一种 HTTP 请求，在一次 GET 请求过程中，web 应用对请求页面的 HTML 进行响应之外，就不需要做任何事情了。特别的，web 应用在 GET 请求的结果中，不应该改变应用的状态（比如，不能基于 GET 请求创建一个新帐号）。正是因为这个原因，GET 请求通常认为是“安全”的，因为他们不会导致应用的改变。</p>
<p>POST：</p>
<p>　　显然，除了简单的查看页面之外，应该还有更多与网站进行交互的操作。我们也能够向应用发送数据，例如通过表单。为了达到这样的目的，就需要一种不同类型的请求方法：POST。POST 请求通常携带由用户输入的数据，web 应用收到之后会产生一些行为。通过在表单里输入你的信息登录一个网站，就是 POST 表单的数据给 web 应用的。</p>
<p>　　不同于 GET 请求，POST 请求通常会导致应用状态的改变。在我们的例子中，当表单 POST 之后，一个新的账户被创建。不同于 GET 请求，POST 请求不总是生成一个新的 HTML 页面发送到客户端，而是客户端使用响应的响应码（response code）来决定对应用的操作是否成功。</p>
<p>HTTTP Response Codes<br>通常来说，web 服务器返回 200 的响应码，意思是，“我已经完成了你要求我做的事情，一切都正常”。响应码总是一个三位数字的代号，web 应用在每个响应的同时都发送一个这样的代号，表明给定的请求的结果。响应码 200 字面意思是“OK”，是响应一个 GET 请求大多情况下都使用的代号。然而对于 POST 请求， 可能会有 204（“No Content”）发送回来，意思是“一切都正常，但是我不准备向你显示任何东西”。</p>
<p>POST 请求仍然会发送一个特殊的 URL，这个 URL 可能和提交数据的页面不同，意识这一点是至关重要的。还是以我们的登录为例，表单可能是在 <a href="http://www.foo.com/signup" target="_blank" rel="noopener">www.foo.com/signup</a> 页面，然而点击 submit，可能会导致带有表单数据的 POST 请求发送到 <a href="http://www.foo.com/process_sigup" target="_blank" rel="noopener">www.foo.com/process_sigup</a> 上。POST 请求要发送的位置在表单的 HTML 中有特别标明。</p>
<p>–web应用</p>
<p>1  一个初级的web应用</p>
<p>你可以仅仅使用 HTTP GET 和 POST 做很多事情。一个应用程序负责去接收一个 HTTP 请求，同时给以 HTTP 响应，通常包含了请求页面的 HTML。POST 请求会引起 web 应用做出一些行为，可能是往数据库中添加一条记录这样的。还有很多其它的 HTTP 方法，但是我们目前只关注 GET 和 POST。</p>
<p>那么最简单的 web 应用是什么样的呢？我们可以写一个应用，让它一直监听 80 端口（著名的 HTTP 端口，几乎所有 HTTP 都发送到这个端口上）。一旦它接收到等待的客户端发送的请求连接，然后它就会回复一些简单的 HTML。</p>
<p>下面是程序的代码：</p>
<p>import socket<br>HOST = ‘’<br>PORT = 80<br>listen_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)<br>listen_socket.bind((HOST, PORT))<br>listen_socket.listen(1)<br>connection, address = listen_socket.accept()<br>request = connection.recv(1024)<br>connection.sendall(b”””HTTP/1.1 200 OK<br>Content-type: text/html</p>
<html>
    <body>
        <h1>Hello, World!</h1>
    </body>
</html>""")
connection.close()



<p>这个代码接收简单的链接和简单的请求，不管请求的 URL 是什么，它都会响应 HTTP 200（所以，这不是一个真正意义上的 web 服务器）。Content-type:text/html 行代码的是 header 字段，header 用来提供请求或者响应的元信息。这样，我们就告诉了客户端接下来的数据是 HTML。</p>
<p>2  优化该web应用</p>
<p>如果我们继续以上面的例子为基础建立 web 应用，我们还需要解决很多问题：</p>
<p>我们怎样检测请求的 URL 并根据不同的URL返回相应的正确的页面？<br>除了简单的 GET 请求之外我们如何处理 POST 请求？<br>我们如何理解更高级的概念，如 session 和 cookie？<br>我们如何扩展程序以使其处理上千个并发连接？<br>围绕建立 web 应用的所有问题中，两个问题尤其突出：</p>
<p>我们如何将请求的 URL 映射到处理它的代码上？<br>我们怎样动态地构造请求的 HTML 返回给客户端，HTML 中带有计算得到的值或者从数据库中取出来的信息？<br>每个 web 框架都以某种方法来解决这些问题，也有很多不同的解决方案。用例子来说明更容易理解，所以我将针对这些问题讨论 Django 和 Flask 的解决方案。但是，首先我们还需要简单讨论一下 MVC 。</p>
<p>–&gt;Django 中的 MVC<br>　　Django 充分利用 MVC 设计模式。 MVC，也就是 Model-View-Controller （模型-视图-控制器），是一种将应用的不同功能从逻辑上划分开。models 代表的是类似数据库表的资源（与 Python 中用 class 来对真实世界目标建模使用的方法大体相同）。controls 包括应用的业务逻辑，对 models 进行操作。为了动态生成代表页面的 HTML，需要 views 给出所有要动态生成页面的 HTML 的信息。</p>
<p>　　在 Django 中有点让人困惑的是，controllers 被称做 views，而 views 被称为 templates。除了名字上的有点奇怪，Django 很好地实现了 MVC 的体系架构。</p>
<p>&lt;–如何解决将请求的 URL 映射到处理它的代码上</p>
<p>Django 中的路由<br>　　路由是处理请求 URL 到负责生成相关的 HTML 的代码之间映射的过程。在简单的情形下，所有的请求都是有相同的代码来处理（就像我们之前的例子那样）。变得稍微复杂一点，每个 URL 对应一个 view function 。举例来说，如果请求 <a href="http://www.foo.com/bar" target="_blank" rel="noopener">www.foo.com/bar</a> 这样的 URL，调用 handler_bar() 这样的函数来产生响应。我们可以建立这样的映射表，枚举出我们应用支持的所有 URL 与它们相关的函数。</p>
<p>　　然而，当 URL 中包含有用的数据，例如资源的 ID（像这样 <a href="http://www.foo.com/users/3/）" target="_blank" rel="noopener">www.foo.com/users/3/）</a> ，那么这种方法将变得非常臃肿。我们如何将 URL 映射到一个 view 函数，同时如何利用我们想显示 ID 为 3 的用户？</p>
<p>　　Django 的答案是，将 URL 正则表达式映射到可以带参数的 view 函数。例如，我假设匹配^/users/(?P<id>\d+)/$ 的 URL 调用 display_user(id) 这样的函数，这儿参数 id 是正则表达式中匹配的 id。这种方法，任何 /users/<some_number>/ 这样的 URL 都会映射到 display_user 函数。这些正则表达式可以非常复杂，包含关键字和参数。</some_number></id></p>
<p>Flask 中的路由<br>　　Flask 采取了一点不同的方法。将一个函数和请求的 URL 关联起来的标准方法是通过使用 route() 装饰器。下面是 Flask 代码，在功能上和上面正则表达式方法相同：</p>
<p>@app.route(‘/users/<a href="id:int" target="_blank" rel="noopener">id:int</a>/‘)<br>def display_user(id):</p>
<pre><code># ...</code></pre><p>　　就像你看到的这样，装饰器使用几乎最简单的正则表达式的形式来将 URL 映射到参数。通过传递给route() 的 URL 中包含的 <a href="name:type" target="_blank" rel="noopener">name:type</a> 指令，可以提取到参数。路由像 /info/about_us.html 这样的静态 URL，可以像你预想的这样 @app.route(‘/info/about_us.html’) 处理。</p>
<p>通过 Templates 动态产生 HTML<br>　　继续上面的例子，一旦我们有合适的代码映射到正确的 URL，我们如何动态生成 HTML？对于 Django 和 Flask，答案都是通过 HTML Templating。</p>
<p>HTML Templating 和使用 str.format() 类似：需要动态输出值的地方使用占位符填充，这些占位符后来通过 str.format() 函数用参数替换掉。想象一下，整个 web 页面就是一个字符串，用括号标明动态数据的位置，最后再调用 str.format() 。Django 模板和 Flask 使用的模板引擎 Jinja2 都使用的是这种方法。</p>
<p>　　然而，不是所有的模板引擎都能相同的功能。Django 支持在模板里基本的编程，而 Jinja2 只能让你执行特定的代码（不是真正意义上的代码，但也差不多）。Jinja2 可以缓存渲染之后的模板，让接下来具有相同参数的请求可以直接从缓存中返回结果，而不是用再次花大力气渲染。</p>
<p>数据库交互<br>　　Django 有着“功能齐全”的设计哲学，其中包含了一个 ORM(Object Realational Mapper， 对象关系映射)，ORM 的目的有两方面：一是将 Python 的 class 与数据库表建立映射，而是剥离出不同数据库引擎直接的差异。没人喜欢 ORM，因为在不同的域之间映射永远不完美，然而这还在承受范围之内。Django 是功能齐全的，而 Flask 是一个微框架，不包括 ORM，尽管它对 SQLAlchemy 兼容性非常好，SQLAlchemy 是 Django ORM 的最大也是唯一的竞争对手。</p>
<p>　　内嵌 ORM 让 Django 有能力创建一个功能丰富的 CRUD 应用，从服务器端角度来看，CRUD（CreateRead Update Delete）应用非常适合使用 web 框架技术。Django 和 Flask-SQLchemy 可以直接对每个 model 进行不同的 CRUD 操作。</p>
<p>再谈 web 框架<br>　　到现在为止，web 框架的目的应该非常清晰了：向程序员隐藏了处理 HTTP 请求和响应相关的基础代码。至于隐藏多少这取决于不同的框架，Django 和 Flask 走向了两个极端：Django 包括了每种情形，几乎成了它致命的一点；Flask 立足于“微框架”，仅仅实现 web 应用需要的最小功能，其它的不常用的 web 框架任务交由第三方库来完成。</p>
<p>　　但是最后要记住的是，Python web 框架都以相同的方式工作的：它们接收 HTTP 请求，分派代码，产生 HTML，创建带有内容的 HTTP 响应。事实上，所有主流的服务器端框架都以这种方式工作的（ JavaScript 框架除外）。但愿了解了这些框架的目的，你能够在不同的框架之间选择适合你应用的框架进行开发。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/04/19/Linux中的文件描述符/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="范澳河">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/微信图片_20190628155231.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="范澳河技术博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/04/19/Linux中的文件描述符/" itemprop="url">Linux中的文件描述符</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-04-19T16:12:22+08:00">
                2018-04-19
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/linux/" itemprop="url" rel="index">
                    <span itemprop="name">linux</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="Linux中的文件描述符"><a href="#Linux中的文件描述符" class="headerlink" title="Linux中的文件描述符"></a>Linux中的文件描述符</h3><ol>
<li>概述<br> 在Linux系统中一切皆可以看成是文件，文件又可分为：普通文件、目录文件、链接文件和设备文件。文件描述符（file descriptor）是内核为了高效管理已被打开的文件所创建的索引，其是一个非负整数（通常是小整数），用于指代被打开的文件，所有执行I/O操作的系统调用都通过文件描述符。程序刚刚启动的时候，0是标准输入，1是标准输出，2是标准错误。如果此时去打开一个新的文件，它的文件描述符会是3。POSIX标准要求每次打开文件时（含socket）必须使用当前进程中最小可用的文件描述符号码，因此，在网络通信过程中稍不注意就有可能造成串话。标准文件描述符图如下：</li>
</ol>
<p>文件描述与打开的文件对应模型如下图：</p>
<ol start="2">
<li><p>文件描述限制</p>
<p> 在编写文件操作的或者网络通信的软件时，初学者一般可能会遇到“Too many open files”的问题。这主要是因为文件描述符是系统的一个重要资源，虽然说系统内存有多少就可以打开多少的文件描述符，但是在实际实现过程中内核是会做相应的处理的，一般最大打开文件数会是系统内存的10%（以KB来计算）（称之为系统级限制），查看系统级别的最大打开文件数可以使用sysctl -a | grep fs.file-max命令查看。与此同时，内核为了不让某一个进程消耗掉所有的文件资源，其也会对单个进程最大打开文件数做默认值处理（称之为用户级限制），默认值一般是1024，使用ulimit -n命令可以查看。在Web服务器中，通过更改系统默认值文件描述符的最大值来优化服务器是最常见的方式之一，具体优化方式请查看<a href="http://blog.csdn.net/kumu_linux/article/details/7877770。" target="_blank" rel="noopener">http://blog.csdn.net/kumu_linux/article/details/7877770。</a></p>
</li>
</ol>
<ol start="3">
<li><p>文件描述符合打开文件之间的关系</p>
<p> 每一个文件描述符会与一个打开文件相对应，同时，不同的文件描述符也会指向同一个文件。相同的文件可以被不同的进程打开也可以在同一个进程中被多次打开。系统为每一个进程维护了一个文件描述符表，该表的值都是从0开始的，所以在不同的进程中你会看到相同的文件描述符，这种情况下相同文件描述符有可能指向同一个文件，也有可能指向不同的文件。具体情况要具体分析，要理解具体其概况如何，需要查看由内核维护的3个数据结构。</p>
<ol>
<li><p>进程级的文件描述符表</p>
</li>
<li><p>系统级的打开文件描述符表</p>
</li>
<li><p>文件系统的i-node表</p>
</li>
</ol>
</li>
</ol>
<p>进程级的描述符表的每一条目记录了单个文件描述符的相关信息。</p>
<pre><code>1. 控制文件描述符操作的一组标志。（目前，此类标志仅定义了一个，即close-on-exec标志）

2. 对打开文件句柄的引用</code></pre><p>内核对所有打开的文件的文件维护有一个系统级的描述符表格（open file description table）。有时，也称之为打开文件表（open file table），并将表格中各条目称为打开文件句柄（open file handle）。一个打开文件句柄存储了与一个打开文件相关的全部信息，如下所示：</p>
<pre><code>1. 当前文件偏移量（调用read()和write()时更新，或使用lseek()直接修改）

2. 打开文件时所使用的状态标识（即，open()的flags参数）

3. 文件访问模式（如调用open()时所设置的只读模式、只写模式或读写模式）

4. 与信号驱动相关的设置

5. 对该文件i-node对象的引用

6. 文件类型（例如：常规文件、套接字或FIFO）和访问权限

7. 一个指针，指向该文件所持有的锁列表

8. 文件的各种属性，包括文件大小以及与不同类型操作相关的时间戳</code></pre><p>下图展示了文件描述符、打开的文件句柄以及i-node之间的关系，图中，两个进程拥有诸多打开的文件描述符。</p>
<pre><code>在进程A中，文件描述符1和30都指向了同一个打开的文件句柄（标号23）。这可能是通过调用dup()、dup2()、fcntl()或者对同一个文件多次调用了open()函数而形成的。

进程A的文件描述符2和进程B的文件描述符2都指向了同一个打开的文件句柄（标号73）。这种情形可能是在调用fork()后出现的（即，进程A、B是父子进程关系），或者当某进程通过UNIX域套接字将一个打开的文件描述符传递给另一个进程时，也会发生。再者是不同的进程独自去调用open函数打开了同一个文件，此时进程内部的描述符正好分配到与其他进程打开该文件的描述符一样。

此外，进程A的描述符0和进程B的描述符3分别指向不同的打开文件句柄，但这些句柄均指向i-node表的相同条目（1976），换言之，指向同一个文件。发生这种情况是因为每个进程各自对同一个文件发起了open()调用。同一个进程两次打开同一个文件，也会发生类似情况。</code></pre><ol start="4">
<li><p>总结</p>
<ol>
<li><p>由于进程级文件描述符表的存在，不同的进程中会出现相同的文件描述符，它们可能指向同一个文件，也可能指向不同的文件</p>
</li>
<li><p>两个不同的文件描述符，若指向同一个打开文件句柄，将共享同一文件偏移量。因此，如果通过其中一个文件描述符来修改文件偏移量（由调用read()、write()或lseek()所致），那么从另一个描述符中也会观察到变化，无论这两个文件描述符是否属于不同进程，还是同一个进程，情况都是如此。</p>
</li>
<li><p>要获取和修改打开的文件标志（例如：O_APPEND、O_NONBLOCK和O_ASYNC），可执行fcntl()的F_GETFL和F_SETFL操作，其对作用域的约束与上一条颇为类似。</p>
</li>
<li><p>文件描述符标志（即，close-on-exec）为进程和文件描述符所私有。对这一标志的修改将不会影响同一进程或不同进程中的其他文件描述符</p>
</li>
</ol>
</li>
</ol>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/03/18/python中的os模块/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="范澳河">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/微信图片_20190628155231.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="范澳河技术博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/03/18/python中的os模块/" itemprop="url">python中的os模块</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-03-18T00:21:57+08:00">
                2018-03-18
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/python/" itemprop="url" rel="index">
                    <span itemprop="name">python</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="os模块"><a href="#os模块" class="headerlink" title="os模块"></a>os模块</h3><p>os模块的作用：</p>
<p>　　os，语义为操作系统，所以肯定就是操作系统相关的功能了，可以处理文件和目录这些我们日常手动需要做的操作，就比如说：显示当前目录下所有文件/删除某个文件/获取文件大小……</p>
<p>　　另外，os模块不受平台限制，也就是说：当我们要在linux中显示当前路径时就要用到pwd命令，而Windows中cmd命令行下就要用到这个，额…我擦，我还真不知道，（甭管怎么着，肯定不是pwd），这时候我们使用python中os模块的os.path.abspath(name)功能，甭管是linux或者Windows都可以获取当前的绝对路径。</p>
<p>os模块的常用功能：</p>
<p>1  os.name      #显示当前使用的平台</p>
<blockquote>
<blockquote>
<blockquote>
<p>os.name<br>‘nt’                  #这表示Windows<br>os.name<br>‘posix’             #这表示Linux<br>2  os.getcwd()      #显示当前python脚本工作路径</p>
</blockquote>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<blockquote>
<p>os.getcwd()<br>‘C:\Users\Capital-D\PycharmProjects\untitled’    #使用pycharm</p>
</blockquote>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<blockquote>
<p>os.getcwd()<br>‘/root’         #Linux平台在/root目录直接使用python3命令<br>3  os.listdir(‘dirname’)        #返回指定目录下的所有文件和目录名</p>
</blockquote>
</blockquote>
</blockquote>
<p>#相对于os.getcwd路径下的文件</p>
<blockquote>
<blockquote>
<blockquote>
<p>os.listdir()<br>[‘.idea’, ‘test’]</p>
</blockquote>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<blockquote>
<p>os.listdir()<br>[‘.bash_logout’, ‘Python-3.4.4’, ‘.mysql_history’, ‘.tcshrc’, ‘Python-3.4.4.tar.xz’, ‘.bash_profile’, ‘.lesshst’, ‘install.log.syslog’, ‘.cshrc’, ‘04.sql’, ‘anaconda-ks.cfg’, ‘test’, ‘.viminfo’, ‘phpMyAdmin-4.4.15-all-languages.tar.bz2’, ‘1test’, ‘.bashrc’, ‘binlog.sql’, ‘back.sql’, ‘install.log’, ‘binlog4.sql’, ‘.bash_history’, ‘backup.sql’, ‘text.py’, ‘.rnd’, ‘test1’]</p>
</blockquote>
</blockquote>
</blockquote>
<p>4  os.remove(‘filename’)       #删除一个文件</p>
<p>[root@slyoyo ~]# touch hahaha<br>[root@slyoyo ~]# ls<br>04.sql           back.sql     binlog.sql   install.log.syslog                       Python-3.4.4.tar.xz  text.py<br>1test            backup.sql   hahaha       phpMyAdmin-4.4.15-all-languages.tar.bz2  test<br>anaconda-ks.cfg  binlog4.sql  install.log  Python-3.4.4                             test1</p>
<p>#hahaha（粉色字体）存在<br>[root@slyoyo ~]# python3<br>Python 3.4.4 (default, Apr  5 2016, 04:23:19)<br>[GCC 4.4.7 20120313 (Red Hat 4.4.7-4)] on linux<br>Type “help”, “copyright”, “credits” or “license” for more information.</p>
<blockquote>
<blockquote>
<blockquote>
<p>import os<br>os.remove(‘hahaha’)<br>exit()<br>[root@slyoyo ~]# ls<br>04.sql  anaconda-ks.cfg  backup.sql   binlog.sql   install.log.syslog                       Python-3.4.4         test   text.py<br>1test   back.sql         binlog4.sql  install.log  phpMyAdmin-4.4.15-all-languages.tar.bz2  Python-3.4.4.tar.xz  test1</p>
</blockquote>
</blockquote>
</blockquote>
<p>#hahaha已被删</p>
<p>5  os.makedirs(‘dirname/dirname’)     #可生成多层递规目录</p>
<p>[root@slyoyo ~]# ls<br>04.sql  anaconda-ks.cfg  backup.sql   binlog.sql   install.log.syslog                       Python-3.4.4         test   text.py<br>1test   back.sql         binlog4.sql  install.log  phpMyAdmin-4.4.15-all-languages.tar.bz2  Python-3.4.4.tar.xz  test1<br>[root@slyoyo ~]# python3<br>Python 3.4.4 (default, Apr  5 2016, 04:23:19)<br>[GCC 4.4.7 20120313 (Red Hat 4.4.7-4)] on linux<br>Type “help”, “copyright”, “credits” or “license” for more information.</p>
<blockquote>
<blockquote>
<blockquote>
<p>import os<br>os.makedirs(‘hahaha/linghuchong’)<br>exit()<br>[root@slyoyo ~]# ls<br>04.sql           back.sql     binlog.sql   install.log.syslog                       Python-3.4.4.tar.xz  text.py<br>1test            backup.sql   hahaha       phpMyAdmin-4.4.15-all-languages.tar.bz2  test<br>anaconda-ks.cfg  binlog4.sql  install.log  Python-3.4.4                             test1<br>[root@slyoyo ~]# ls hahaha/<br>linghuchong<br>[root@slyoyo ~]# ls hahaha/linghuchong/<br>[root@slyoyo ~]# </p>
</blockquote>
</blockquote>
</blockquote>
<p>6  os.rmdir(‘dirname’)     #删除单级目录</p>
<p>[root@slyoyo ~]# ls<br>04.sql           back.sql     binlog.sql   install.log.syslog                       Python-3.4.4.tar.xz  text.py<br>1test            backup.sql   hahaha       phpMyAdmin-4.4.15-all-languages.tar.bz2  test<br>anaconda-ks.cfg  binlog4.sql  install.log  Python-3.4.4                             test1<br>[root@slyoyo ~]# ls hahaha/<br>linghuchong<br>[root@slyoyo ~]# ls hahaha/linghuchong/<br>[root@slyoyo ~]# python3<br>Python 3.4.4 (default, Apr  5 2016, 04:23:19)<br>[GCC 4.4.7 20120313 (Red Hat 4.4.7-4)] on linux<br>Type “help”, “copyright”, “credits” or “license” for more information.</p>
<blockquote>
<blockquote>
<blockquote>
<p>import os<br>os.rmdir(‘hahaha/linghuchong’)<br>exit()<br>[root@slyoyo ~]# ls hahaha/<br>[root@slyoyo ~]# </p>
</blockquote>
</blockquote>
</blockquote>
<p>7  os.rename(“oldname”,”newname”)    #重命名文件</p>
<blockquote>
<blockquote>
<blockquote>
<p>os.getcwd()<br>‘/root/hahaha’<br>os.listdir()<br>[‘test’]<br>os.rename(‘test’,’test_new’)<br>os.listdir()<br>[‘test_new’]</p>
</blockquote>
</blockquote>
</blockquote>
<p>8  os.system()    #运行shell命令,注意：这里是打开一个新的shell，运行命令，当命令结束后，关闭shell</p>
<blockquote>
<blockquote>
<blockquote>
<p>os.system(‘pwd’)<br>/root/hahaha<br>0
9  os.sep    #显示当前平台下路径分隔符</p>
</blockquote>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<blockquote>
<p>os.sep<br>‘/‘               #linux</p>
</blockquote>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<blockquote>
<p>os.sep<br>‘\‘             #windows<br>10  os.linesep    #给出当前平台使用的行终止符</p>
</blockquote>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<blockquote>
<p>os.linesep<br>‘\n’      #linux</p>
</blockquote>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<blockquote>
<p>os.linesep<br>‘\r\n’    #windows<br>11  os.environ    #获取系统环境变量</p>
</blockquote>
</blockquote>
</blockquote>
<p>os.environ<br>environ({‘USERPROFILE’: ‘C:\Users\Capital-D’, ‘PROCESSOR_ARCHITECTURE’: ‘x86’, ‘SESSIONNAME’: ‘Console’, ‘UGII_BASE_DIR’: ‘D:\Program Files (x86)\Siemens\NX 8.0’, ‘COMMONPROGRAMW6432’: ‘C:\Program Files\Common Files’, ‘COMMONPROGRAMFILES(X86)’: ‘C:\Program Files (x86)\Common Files’, ‘MOZ_PLUGIN_PATH’: ‘C:\Program Files (x86)\Foxit Software\Foxit Reader\plugins\‘, ‘ALLUSERSPROFILE’: ‘C:\ProgramData’, ‘PYTHONIOENCODING’: ‘UTF-8’, ‘NUMBER_OF_PROCESSORS’: ‘4’, ‘APPDATA’: ‘C:\Users\Capital-D\AppData\Roaming’, ‘TERM’: ‘emacs’, ‘TEMP’: ‘C:\Users\CAPITA<del>1\AppData\Local\Temp’, ‘PROGRAMDATA’: ‘C:\ProgramData’, ‘COMSPEC’: ‘C:\windows\system32\cmd.exe’, ‘WINDIR’: ‘C:\windows’, ‘PROCESSOR_IDENTIFIER’: ‘Intel64 Family 6 Model 58 Stepping 9, GenuineIntel’, ‘PATHEXT’: ‘.COM;.EXE;.BAT;.CMD;.VBS;.VBE;.JS;.JSE;.WSF;.WSH;.MSC;.PY’, ‘PATH’: ‘C:\ProgramData\Oracle\Java\javapath;C:\Program Files (x86)\Common Files\NetSarang;C:\Program Files (x86)\NVIDIA Corporation\PhysX\Common;C:\Program Files (x86)\Intel\iCLS Client\;C:\Program Files\Intel\iCLS Client\;C:\windows\system32;C:\windows;C:\windows\System32\Wbem;C:\windows\System32\WindowsPowerShell\v1.0\;C:\Program Files\Intel\Intel(R) Management Engine Components\DAL;C:\Program Files\Intel\Intel(R) Management Engine Components\IPT;C:\Program Files (x86)\Intel\Intel(R) Management Engine Components\DAL;C:\Program Files (x86)\Intel\Intel(R) Management Engine Components\IPT’, ‘UGII_ROOT_DIR’: ‘D:\Program Files (x86)\Siemens\NX 8.0\UGII\‘, ‘COMPUTERNAME’: ‘IDEA-PC’, ‘USERDOMAIN’: ‘idea-PC’, ‘TMP’: ‘C:\Users\CAPITA</del>1\AppData\Local\Temp’, ‘SYSTEMROOT’: ‘C:\windows’, ‘PROCESSOR_REVISION’: ‘3a09’, ‘FP_NO_HOST_CHECK’: ‘NO’, ‘PROGRAMFILES’: ‘C:\Program Files (x86)’, ‘PYTHONDONTWRITEBYTECODE’: ‘1’, ‘LOCALAPPDATA’: ‘C:\Users\Capital-D\AppData\Local’, ‘PYTHONUNBUFFERED’: ‘1’, ‘LOGONSERVER’: ‘\\IDEA-PC’, ‘UGII_LANG’: ‘simpl_chinese’, ‘SYSTEMDRIVE’: ‘C:’, ‘PUBLIC’: ‘C:\Users\Public’, ‘HOMEPATH’: ‘\Users\Capital-D’, ‘PYTHONPATH’: ‘C:\Program Files (x86)\JetBrains\PyCharm 5.0.2\helpers\pydev’, ‘USERNAME’: ‘Capital-D’, ‘UGS_LICENSE_SERVER’: ‘28000@idea-pc’, ‘USERDOMAIN_ROAMINGPROFILE’: ‘idea-PC’, ‘PYCHARM_HOSTED’: ‘1’, ‘OS’: ‘Windows_NT’, ‘PROCESSOR_ARCHITEW6432’: ‘AMD64’, ‘PROGRAMFILES(X86)’: ‘C:\Program Files (x86)’, ‘PROGRAMW6432’: ‘C:\Program Files’, ‘PSMODULEPATH’: ‘C:\windows\system32\WindowsPowerShell\v1.0\Modules\‘, ‘COMMONPROGRAMFILES’: ‘C:\Program Files (x86)\Common Files’, ‘IPYTHONENABLE’: ‘True’, ‘HOMEDRIVE’: ‘C:’, ‘CONFIGSETROOT’: ‘C:\windows\ConfigSetRoot’, ‘PROCESSOR_LEVEL’: ‘6’})</p>
<p>12  os.path.abspath(path)    #显示当前绝对路径</p>
<blockquote>
<blockquote>
<blockquote>
<p>os.path.abspath(‘test’)<br>‘C:\Users\Capital-D\PycharmProjects\untitled\test’<br>13  os.path.dirname(path)    #返回该路径的父目录</p>
</blockquote>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<blockquote>
<p>os.path.abspath(‘test’)<br>‘C:\Users\Capital-D\PycharmProjects\untitled\test’<br>os.path.dirname(os.path.abspath(‘test’))<br>‘C:\Users\Capital-D\PycharmProjects\untitled’<br>14  os.path.basename(path)    #返回该路径的最后一个目录或者文件,如果path以／或\结尾，那么就会返回空值。</p>
</blockquote>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<blockquote>
<p>os.path.dirname(os.path.abspath(‘test’))<br>‘C:\Users\Capital-D\PycharmProjects\untitled’<br>os.path.basename(os.path.dirname(os.path.abspath(‘test’)))<br>‘untitled’<br>15  os.path.isfile(path)     #如果path是一个文件，则返回True</p>
</blockquote>
</blockquote>
</blockquote>
<p>[root@slyoyo ~]# ls<br>04.sql           back.sql     binlog.sql   install.log.syslog                       Python-3.4.4.tar.xz  text.py<br>1test            backup.sql   hahaha       phpMyAdmin-4.4.15-all-languages.tar.bz2  test<br>anaconda-ks.cfg  binlog4.sql  install.log  Python-3.4.4                             test1<br>[root@slyoyo ~]# python3<br>Python 3.4.4 (default, Apr  5 2016, 04:23:19)<br>[GCC 4.4.7 20120313 (Red Hat 4.4.7-4)] on linux<br>Type “help”, “copyright”, “credits” or “license” for more information.</p>
<blockquote>
<blockquote>
<blockquote>
<p>import os<br>os.path.isfile(‘test’)<br>True</p>
</blockquote>
</blockquote>
</blockquote>
<p>16  os.path.isdir(path)    #如果path是一个目录，则返回True</p>
<blockquote>
<blockquote>
<blockquote>
<p>os.path.isdir(‘hahaha’)<br>True<br>17  os.stat()    #获取文件或者目录信息</p>
</blockquote>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<blockquote>
<p>os.stat(‘test’)<br>os.stat_result(st_mode=33188, st_ino=137149, st_dev=2050, st_nlink=1, st_uid=0, st_gid=0, st_size=85, st_atime=1462373193, st_mtime=1462373186, st_ctime=1462373186)<br>18  os.path.split(path)  #将path分割成路径名和文件名。（事实上，如果你完全使用目录，它也会将最后一个目录作为文件名而分离，同时它不会判断文件或目录是否存在）</p>
</blockquote>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<blockquote>
<p>os.path.split(‘/root/test’)<br>(‘/root’, ‘test’)<br>19  os.path.join(path,name)   #连接目录与文件名或目录 结果为path/name</p>
</blockquote>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<blockquote>
<p>os.path.join(‘/root/haha’,’test’)<br>‘/root/haha/test’</p>
</blockquote>
</blockquote>
</blockquote>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/03/17/uwsgi多进程配合kafka-python消息无法发送/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="范澳河">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/微信图片_20190628155231.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="范澳河技术博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/03/17/uwsgi多进程配合kafka-python消息无法发送/" itemprop="url">uwsgi多进程配合kafka-python消息无法发送</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-03-17T16:12:22+08:00">
                2018-03-17
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/python/" itemprop="url" rel="index">
                    <span itemprop="name">python</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="uwsgi多进程配合kafka-python消息无法发送"><a href="#uwsgi多进程配合kafka-python消息无法发送" class="headerlink" title="uwsgi多进程配合kafka-python消息无法发送"></a>uwsgi多进程配合kafka-python消息无法发送</h3><p>在工作中，使用uwsgi部署项目，其中uwsgi设置为多进程，并且python中使用了kafka-python模块作为生产者不断产生数据，但上线不久后几乎所有的生产者消息都报：KafkaTimeoutError这个错误，并且在kafka服务器中并没有发现收到任何消息。</p>
<p>于是看了看kafka-python源码，发现在执行send方法后，消息并没有立即发送，而是放到本地的缓存中，在生成KafkaProducer实例时，有个选项buffer_memory设置了缓存的大小，默认为32M，然后如果这个buffer满了就会报KafkaTimeoutError，所以初步判断两个原因：</p>
<p>　　1 生产者消息并没有发送出去，</p>
<p>　　2 或者消息发送相对于消息生成来说过于缓慢导致</p>
<p>同时又因为看到kafka服务器中并没有接收到任何消息，遂排除第二个原因。也就是说生产者消息没有发送出去。于是采用同样的配置用写了一个脚本发现kafka服务器可以接收到消息，鉴定是我的生产者有问题，遂谷歌解决问题，找到该帖子：<a href="https://github.com/dpkp/kafka-python/issues/721。发布人情况和我差不多，作者回复到：" target="_blank" rel="noopener">https://github.com/dpkp/kafka-python/issues/721。发布人情况和我差不多，作者回复到：</a></p>
<p>You cannot share producer instances across processes, only threads. I expect that is why the master process pattern is failing.</p>
<p>Second, producer.send() is async but is not guaranteed to deliver if you close the producer abruptly. In your final example I suspect that your producer instances are so short-lived that they are being reaped before flushing all pending messages. To guarantee delivery (or exception) call producer.send().get(timeout) or producer.flush() . otherwise you’ll need to figure out how to get a producer instance per-uwsgi-thread and have it shared across requests (you would still want to flush before thread shutdown to guarantee no messages are dropped)</p>
<p>大体上说明了两点：</p>
<p>　　1 多进程共享同一个生产者实例有问题</p>
<p>　　2 send方法是异步的，当执行完send后立即关闭生产者实例的话可能会导致发送失败。</p>
<p>第二点错误我没有犯，沾沾自喜，继续看评论：</p>
<p>Aha, thanks! After looking more closely at uWSGI options I discovered the lazy-apps option, which causes each worker to load the entire app itself. This seems to have resolved my issue.</p>
<p>提问者说他解决了该问题，于是查一查uwsgi中的lazy-apps，发现改文章：<a href="https://uwsgi-docs-zh.readthedocs.io/zh_CN/latest/articles/TheArtOfGracefulReloading.html#preforking-vs-lazy-apps-vs-lazy，其中说到：" target="_blank" rel="noopener">https://uwsgi-docs-zh.readthedocs.io/zh_CN/latest/articles/TheArtOfGracefulReloading.html#preforking-vs-lazy-apps-vs-lazy，其中说到：</a></p>
<p>默认情况下，uWSGI在第一个进程中加载整个应用，然后在加载完应用之后，会多次 fork() 自己。</p>
<p>我看看了我自己的代码我确实是在app生成之前生成了生产者实例，这就导致该实例被父进程与其子进程共享。问题终于明白，开始解决：</p>
<p>　　1 使用lazy-apps，这样就可以了。</p>
<p>　　2 不使用lazy-apps，在代码层面解决问题：　</p>
<h1 id="producer-py文件"><a href="#producer-py文件" class="headerlink" title="producer.py文件"></a>producer.py文件</h1><p>import json<br>from kafka import KafkaProducer</p>
<p>class Single(object):<br>    “””单例模式”””<br>    def <strong>new</strong>(cls, <em>args, **kwargs):<br>        if not hasattr(cls, “<em>instance”):<br>            cls.<em>instance = super().__new</em></em>(cls)<br>            if hasattr(cls, “initialize”):<br>                cls._instance.initialize(</em>args, **kwargs)<br>        return cls._instance</p>
<p>class MsgQueue(Single):<br>    “””<br>    这个整成单例模式是因为：uwsgi配合kafka-python在多进程下会有问题，这里希望每个进程单独享有一个kafka producer实例,<br>    也就是说当初始化app对象后，并不会生成producer实例，而是在运行时再生成，<br>    具体参考：<a href="https://github.com/dpkp/kafka-python/issues/721" target="_blank" rel="noopener">https://github.com/dpkp/kafka-python/issues/721</a><br>    “””<br>    app = None</p>
<pre><code>def initialize(self):
    self.producer = KafkaProducer(bootstrap_servers=self.app.config[&quot;MQ_URI&quot;],
                                  api_version=self.app.config[&quot;KAFKA_API_VERSION&quot;])

@classmethod
def init_app(cls, app):
    cls.app = app

def send(self, topic, data):
    &quot;&quot;&quot;
    :param topic:
    :param data:
    :return:
    &quot;&quot;&quot;
    data = json.dumps(data, ensure_ascii=True)
    self.producer.send(topic, data.encode())</code></pre><h1 id="app-py文件"><a href="#app-py文件" class="headerlink" title="app.py文件"></a>app.py文件</h1><p>from producer import MsgQueue<br>…<br>MsgQueue.init_app(app)</p>
<h1 id="业务逻辑中用到生产者的文件"><a href="#业务逻辑中用到生产者的文件" class="headerlink" title="业务逻辑中用到生产者的文件"></a>业务逻辑中用到生产者的文件</h1><p>from producer import MsgQueue<br>…<br>MsgQueue().send(msg)</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/03/09/拥有root权限却报错Access denied/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="范澳河">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/微信图片_20190628155231.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="范澳河技术博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/03/09/拥有root权限却报错Access denied/" itemprop="url">拥有root权限却报错Access denied</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-03-09T16:12:22+08:00">
                2018-03-09
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/jquery/" itemprop="url" rel="index">
                    <span itemprop="name">jquery</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="拥有root权限却报错Access-denied"><a href="#拥有root权限却报错Access-denied" class="headerlink" title="拥有root权限却报错Access denied"></a>拥有root权限却报错Access denied</h3><p>起因：我在centos7上根据mysql官网配置安装mysql 5.7.20，安装完成后希望其能够开机自动启动，于是乎运行命令：</p>
<p>systemctl enable mysqld<br>结果出现错误：</p>
<p>Failed to execute operation: Access denied<br>我勒个去！ 我可是root好不好啊，于是上网查了查，发现没有关闭selinux,关于selinux我一直困惑了很久，只是知道：如果对一个文件没有正确安全上下文配置， 甚至你是root用户，你也不能启动某服务</p>
<p>setenforce 0<br>然后再次运行systemctl enable mysqld成功！</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/3/"><i class="fa fa-angle-left"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/3/">3</a><span class="page-number current">4</span><a class="page-number" href="/page/5/">5</a><span class="space">&hellip;</span><a class="page-number" href="/page/7/">7</a><a class="extend next" rel="next" href="/page/5/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview sidebar-panel sidebar-panel-active">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image" src="/images/微信图片_20190628155231.jpg" alt="范澳河">
          <p class="site-author-name" itemprop="name">范澳河</p>
           
              <p class="site-description motion-element" itemprop="description">Python全栈开发</p>
          
        </div>
        <nav class="site-state motion-element">

          
            <div class="site-state-item site-state-posts">
              <a href="/archives/">
                <span class="site-state-item-count">61</span>
                <span class="site-state-item-name">日志</span>
              </a>
            </div>
          

          
            
            
            <div class="site-state-item site-state-categories">
              <a href="/categories/index.html">
                <span class="site-state-item-count">11</span>
                <span class="site-state-item-name">分类</span>
              </a>
            </div>
          

          
            
            
            <div class="site-state-item site-state-tags">
              <a href="/tags/index.html">
                <span class="site-state-item-count">14</span>
                <span class="site-state-item-name">标签</span>
              </a>
            </div>
          

        </nav>

        

        <div class="links-of-author motion-element">
          
        </div>

        
        

        
        

        


      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2019</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">范澳河</span>
</div>


<div class="powered-by">
  由 <a class="theme-link" href="https://hexo.io">Hexo</a> 强力驱动
</div>

<div class="theme-info">
  主题 -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Gemini
  </a>
</div>


        

        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.2"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.2"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.2"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.2"></script>



  
    <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.2"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.2"></script>

  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.2"></script>



  


  




	





  





  






  





  

  

  

  

  

  

</body>
</html>
